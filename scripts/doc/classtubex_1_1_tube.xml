<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.13">
  <compounddef id="classtubex_1_1_tube" kind="class" language="C++" prot="public">
    <compoundname>tubex::Tube</compoundname>
    <basecompoundref refid="classtubex_1_1_dynamical_item" prot="public" virt="non-virtual">tubex::DynamicalItem</basecompoundref>
    <includes refid="tubex___tube_8h" local="no">tubex_Tube.h</includes>
      <sectiondef kind="user-defined">
      <header>Definition</header>
      <memberdef kind="function" id="classtubex_1_1_tube_1ac91f4b104f474a0940f897a75aae82d8" prot="public" static="no" const="no" explicit="yes" inline="no" virt="non-virtual">
        <type></type>
        <definition>tubex::Tube::Tube</definition>
        <argsstring>(const ibex::Interval &amp;tdomain, const ibex::Interval &amp;codomain=ibex::Interval::ALL_REALS)</argsstring>
        <name>Tube</name>
        <param>
          <type>const ibex::Interval &amp;</type>
          <declname>tdomain</declname>
        </param>
        <param>
          <type>const ibex::Interval &amp;</type>
          <declname>codomain</declname>
          <defval>ibex::Interval::ALL_REALS</defval>
        </param>
        <briefdescription>
<para>Creates a scalar tube <formula id="77">$[x](\cdot)$</formula> made of one slice. </para>        </briefdescription>
        <detaileddescription>
<para><anchor id="classtubex_1_1_tube_1DOC__TUBE_CONSTRUCT_1"/> <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>tdomain</parametername>
</parameternamelist>
<parameterdescription>
<para>temporal domain <formula id="175">$[t_0,t_f]$</formula> </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>codomain</parametername>
</parameternamelist>
<parameterdescription>
<para>Interval value of the slice (all reals <formula id="213">$[-\infty,\infty]$</formula> by default) </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/simon/tubex-lib/src/core/dynamics/tube/tubex_Tube.h" line="59" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classtubex_1_1_tube_1af4e716a0e7fb4329871bc234d4294cfa" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type></type>
        <definition>tubex::Tube::Tube</definition>
        <argsstring>(const ibex::Interval &amp;tdomain, double timestep, const ibex::Interval &amp;codomain=ibex::Interval::ALL_REALS)</argsstring>
        <name>Tube</name>
        <param>
          <type>const ibex::Interval &amp;</type>
          <declname>tdomain</declname>
        </param>
        <param>
          <type>double</type>
          <declname>timestep</declname>
        </param>
        <param>
          <type>const ibex::Interval &amp;</type>
          <declname>codomain</declname>
          <defval>ibex::Interval::ALL_REALS</defval>
        </param>
        <briefdescription>
<para>Creates a scalar tube <formula id="77">$[x](\cdot)$</formula> with some temporal discretization. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>tdomain</parametername>
</parameternamelist>
<parameterdescription>
<para>temporal domain <formula id="175">$[t_0,t_f]$</formula> </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>timestep</parametername>
</parameternamelist>
<parameterdescription>
<para>sampling value <formula id="231">$\delta$</formula> for the temporal discretization (double) </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>codomain</parametername>
</parameternamelist>
<parameterdescription>
<para>Interval value of the slices (all reals <formula id="213">$[-\infty,\infty]$</formula> by default) </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/simon/tubex-lib/src/core/dynamics/tube/tubex_Tube.h" line="68" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classtubex_1_1_tube_1ac07929ace82b7303888f8378a48f2147" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type></type>
        <definition>tubex::Tube::Tube</definition>
        <argsstring>(const ibex::Interval &amp;tdomain, double timestep, const TFnc &amp;f, int f_image_id=0)</argsstring>
        <name>Tube</name>
        <param>
          <type>const ibex::Interval &amp;</type>
          <declname>tdomain</declname>
        </param>
        <param>
          <type>double</type>
          <declname>timestep</declname>
        </param>
        <param>
          <type>const TFnc &amp;</type>
          <declname>f</declname>
        </param>
        <param>
          <type>int</type>
          <declname>f_image_id</declname>
          <defval>0</defval>
        </param>
        <briefdescription>
<para>Creates a scalar tube <formula id="77">$[x](\cdot)$</formula> from a TFnc object and with some temporal discretization. </para>        </briefdescription>
        <detaileddescription>
<para><simplesect kind="note"><para>Due to the slicing implementation of the tube, a wrapping effect will occur to reliably enclose the TFnc object</para></simplesect>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>tdomain</parametername>
</parameternamelist>
<parameterdescription>
<para>temporal domain <formula id="175">$[t_0,t_f]$</formula> </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>timestep</parametername>
</parameternamelist>
<parameterdescription>
<para>sampling value <formula id="231">$\delta$</formula> for the temporal discretization (double) </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>f</parametername>
</parameternamelist>
<parameterdescription>
<para>TFnc object that will be enclosed by the tube: <formula id="251">$\forall t\in[t_0,t_f], [f](t)\subseteq[x](t)$</formula> </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>f_image_id</parametername>
</parameternamelist>
<parameterdescription>
<para>component index of the interval function <formula id="252">$[f]$</formula> (that is possibly multidimensional, first component by default) </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/simon/tubex-lib/src/core/dynamics/tube/tubex_Tube.h" line="83" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classtubex_1_1_tube_1a1714cc72ebc4d52f40d60b72ef7d6ad6" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type></type>
        <definition>tubex::Tube::Tube</definition>
        <argsstring>(const std::vector&lt; ibex::Interval &gt; &amp;v_tdomains, const std::vector&lt; ibex::Interval &gt; &amp;v_codomains)</argsstring>
        <name>Tube</name>
        <param>
          <type>const std::vector&lt; ibex::Interval &gt; &amp;</type>
          <declname>v_tdomains</declname>
        </param>
        <param>
          <type>const std::vector&lt; ibex::Interval &gt; &amp;</type>
          <declname>v_codomains</declname>
        </param>
        <briefdescription>
<para>Creates a tube <formula id="77">$[x](\cdot)$</formula> from a list of <formula id="253">$k$</formula> boxes <formula id="254">$\big([t_1]\times[x_1],\dots,[t_k]\times[x_k]\big)$</formula>. </para>        </briefdescription>
        <detaileddescription>
<para><simplesect kind="note"><para>The slicing will be based on the vector of temporal domains. </para></simplesect>
<simplesect kind="note"><para>The <formula id="255">$[t_i]$</formula>&apos;s must cover continuously the tdomain of <formula id="77">$[x](\cdot)$</formula>.</para></simplesect>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>v_tdomains</parametername>
</parameternamelist>
<parameterdescription>
<para>vector of temporal domains <formula id="255">$[t_i]$</formula> </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>v_codomains</parametername>
</parameternamelist>
<parameterdescription>
<para>vector of codomains <formula id="256">$[x_i]$</formula> related to the <formula id="255">$[t_i]$</formula>&apos;s </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/simon/tubex-lib/src/core/dynamics/tube/tubex_Tube.h" line="94" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classtubex_1_1_tube_1a665f923072ea0ee7fe4efcd6f538d529" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type></type>
        <definition>tubex::Tube::Tube</definition>
        <argsstring>(const Tube &amp;x)</argsstring>
        <name>Tube</name>
        <param>
          <type>const <ref refid="classtubex_1_1_tube" kindref="compound">Tube</ref> &amp;</type>
          <declname>x</declname>
        </param>
        <briefdescription>
<para>Creates a copy of a scalar tube <formula id="77">$[x](\cdot)$</formula>, with the same time discretization. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>x</parametername>
</parameternamelist>
<parameterdescription>
<para><ref refid="classtubex_1_1_tube" kindref="compound">Tube</ref> to be duplicated </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/simon/tubex-lib/src/core/dynamics/tube/tubex_Tube.h" line="101" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classtubex_1_1_tube_1a0b62385ad38bc9769e88cd5d81047154" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type></type>
        <definition>tubex::Tube::Tube</definition>
        <argsstring>(const Tube &amp;x, const ibex::Interval &amp;codomain)</argsstring>
        <name>Tube</name>
        <param>
          <type>const <ref refid="classtubex_1_1_tube" kindref="compound">Tube</ref> &amp;</type>
          <declname>x</declname>
        </param>
        <param>
          <type>const ibex::Interval &amp;</type>
          <declname>codomain</declname>
        </param>
        <briefdescription>
<para>Creates a copy of a scalar tube <formula id="77">$[x](\cdot)$</formula>, with the same time discretization but a specific constant codomain. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>x</parametername>
</parameternamelist>
<parameterdescription>
<para><ref refid="classtubex_1_1_tube" kindref="compound">Tube</ref> from which the sampling will be duplicated </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>codomain</parametername>
</parameternamelist>
<parameterdescription>
<para>Interval value of the slices </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/simon/tubex-lib/src/core/dynamics/tube/tubex_Tube.h" line="110" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classtubex_1_1_tube_1a4e227ab701eb3ff9264e2c4459a1414b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type></type>
        <definition>tubex::Tube::Tube</definition>
        <argsstring>(const Tube &amp;x, const TFnc &amp;f, int f_image_id=0)</argsstring>
        <name>Tube</name>
        <param>
          <type>const <ref refid="classtubex_1_1_tube" kindref="compound">Tube</ref> &amp;</type>
          <declname>x</declname>
        </param>
        <param>
          <type>const TFnc &amp;</type>
          <declname>f</declname>
        </param>
        <param>
          <type>int</type>
          <declname>f_image_id</declname>
          <defval>0</defval>
        </param>
        <briefdescription>
<para>Creates a copy of a scalar tube <formula id="77">$[x](\cdot)$</formula>, with the same time discretization but a specific codomain defined by a TFnc object. </para>        </briefdescription>
        <detaileddescription>
<para><simplesect kind="note"><para>Due to the slicing implementation of the tube, a wrapping effect will occur to reliably enclose the TFnc object</para></simplesect>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>x</parametername>
</parameternamelist>
<parameterdescription>
<para><ref refid="classtubex_1_1_tube" kindref="compound">Tube</ref> from which the sampling will be duplicated </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>f</parametername>
</parameternamelist>
<parameterdescription>
<para>TFnc object that will be enclosed by the tube: <formula id="251">$\forall t\in[t_0,t_f], [f](t)\subseteq[x](t)$</formula> </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>f_image_id</parametername>
</parameternamelist>
<parameterdescription>
<para>component index of the interval function <formula id="252">$[f]$</formula> (that is possibly multidimensional, first component by default) </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/simon/tubex-lib/src/core/dynamics/tube/tubex_Tube.h" line="125" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classtubex_1_1_tube_1ab23c1783a0736340c03b1c737cc82690" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type></type>
        <definition>tubex::Tube::Tube</definition>
        <argsstring>(const Trajectory &amp;traj, double timestep)</argsstring>
        <name>Tube</name>
        <param>
          <type>const <ref refid="classtubex_1_1_trajectory" kindref="compound">Trajectory</ref> &amp;</type>
          <declname>traj</declname>
        </param>
        <param>
          <type>double</type>
          <declname>timestep</declname>
        </param>
        <briefdescription>
<para>Creates a scalar tube <formula id="77">$[x](\cdot)$</formula> enclosing a trajectory <formula id="22">$x(\cdot)$</formula>, possibly with some temporal discretization. </para>        </briefdescription>
        <detaileddescription>
<para><simplesect kind="note"><para>Due to the slicing implementation of the tube, a wrapping effect will occur to reliably enclose the <ref refid="classtubex_1_1_trajectory" kindref="compound">Trajectory</ref> object</para></simplesect>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>traj</parametername>
</parameternamelist>
<parameterdescription>
<para><ref refid="classtubex_1_1_trajectory" kindref="compound">Trajectory</ref> <formula id="22">$x(\cdot)$</formula> to enclose </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>timestep</parametername>
</parameternamelist>
<parameterdescription>
<para>sampling value <formula id="231">$\delta$</formula> for the temporal discretization (double, no discretization by default: one slice only) </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/simon/tubex-lib/src/core/dynamics/tube/tubex_Tube.h" line="138" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classtubex_1_1_tube_1a5d1633d16c844c2c38f8c9975d9023b0" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type></type>
        <definition>tubex::Tube::Tube</definition>
        <argsstring>(const Trajectory &amp;lb, const Trajectory &amp;ub, double timestep)</argsstring>
        <name>Tube</name>
        <param>
          <type>const <ref refid="classtubex_1_1_trajectory" kindref="compound">Trajectory</ref> &amp;</type>
          <declname>lb</declname>
        </param>
        <param>
          <type>const <ref refid="classtubex_1_1_trajectory" kindref="compound">Trajectory</ref> &amp;</type>
          <declname>ub</declname>
        </param>
        <param>
          <type>double</type>
          <declname>timestep</declname>
        </param>
        <briefdescription>
<para>Creates a scalar tube <formula id="77">$[x](\cdot)$</formula> defined as an interval of two trajectories <formula id="257">$[lb(\cdot),ub(\cdot)]$</formula>. </para>        </briefdescription>
        <detaileddescription>
<para><simplesect kind="note"><para>Due to the slicing implementation of the tube, a wrapping effect will occur to reliably enclose the <ref refid="classtubex_1_1_trajectory" kindref="compound">Trajectory</ref> object</para></simplesect>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>lb</parametername>
</parameternamelist>
<parameterdescription>
<para><ref refid="classtubex_1_1_trajectory" kindref="compound">Trajectory</ref> defining the lower bound <formula id="258">$x^{-}(\cdot)$</formula> of the tube </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>ub</parametername>
</parameternamelist>
<parameterdescription>
<para><ref refid="classtubex_1_1_trajectory" kindref="compound">Trajectory</ref> defining the upper bound <formula id="259">$x^{+}(\cdot)$</formula> of the tube </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>timestep</parametername>
</parameternamelist>
<parameterdescription>
<para>sampling value <formula id="231">$\delta$</formula> for the temporal discretization (double, no discretization by default: one slice only) </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/simon/tubex-lib/src/core/dynamics/tube/tubex_Tube.h" line="152" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classtubex_1_1_tube_1a8f1128f8c38b6ae3dc0122a6f6046935" prot="public" static="no" const="no" explicit="yes" inline="no" virt="non-virtual">
        <type></type>
        <definition>tubex::Tube::Tube</definition>
        <argsstring>(const std::string &amp;binary_file_name)</argsstring>
        <name>Tube</name>
        <param>
          <type>const std::string &amp;</type>
          <declname>binary_file_name</declname>
        </param>
        <briefdescription>
<para>Restore a scalar tube from serialization. </para>        </briefdescription>
        <detaileddescription>
<para><simplesect kind="note"><para>The <ref refid="classtubex_1_1_tube" kindref="compound">Tube</ref> must have been serialized beforehand by the appropriate method <ref refid="classtubex_1_1_tube_1ab6cb813c5fe3e3e6e1bd0bb0861552bb" kindref="member">serialize()</ref></para></simplesect>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>binary_file_name</parametername>
</parameternamelist>
<parameterdescription>
<para>path to the binary file </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/simon/tubex-lib/src/core/dynamics/tube/tubex_Tube.h" line="161" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classtubex_1_1_tube_1a0580667fecbabea51daa2fb8f755e3cf" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type></type>
        <definition>tubex::Tube::Tube</definition>
        <argsstring>(const std::string &amp;binary_file_name, Trajectory *&amp;traj)</argsstring>
        <name>Tube</name>
        <param>
          <type>const std::string &amp;</type>
          <declname>binary_file_name</declname>
        </param>
        <param>
          <type><ref refid="classtubex_1_1_trajectory" kindref="compound">Trajectory</ref> *&amp;</type>
          <declname>traj</declname>
        </param>
        <briefdescription>
<para>Restore a scalar tube from serialization, together with a <ref refid="classtubex_1_1_trajectory" kindref="compound">Trajectory</ref> object. </para>        </briefdescription>
        <detaileddescription>
<para><simplesect kind="note"><para>The <ref refid="classtubex_1_1_tube" kindref="compound">Tube</ref> and the <ref refid="classtubex_1_1_trajectory" kindref="compound">Trajectory</ref> must have been serialized beforehand by the appropriate method <ref refid="classtubex_1_1_tube_1ab6cb813c5fe3e3e6e1bd0bb0861552bb" kindref="member">serialize()</ref></para></simplesect>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>binary_file_name</parametername>
</parameternamelist>
<parameterdescription>
<para>path to the binary file </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>traj</parametername>
</parameternamelist>
<parameterdescription>
<para>a pointer to the <ref refid="classtubex_1_1_trajectory" kindref="compound">Trajectory</ref> object to be instantiated </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/simon/tubex-lib/src/core/dynamics/tube/tubex_Tube.h" line="172" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classtubex_1_1_tube_1a46cf4d1c4944715c5d220712be040b67" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type></type>
        <definition>tubex::Tube::~Tube</definition>
        <argsstring>()</argsstring>
        <name>~Tube</name>
        <briefdescription>
<para><ref refid="classtubex_1_1_tube" kindref="compound">Tube</ref> destructor. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/simon/tubex-lib/src/core/dynamics/tube/tubex_Tube.h" line="177" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classtubex_1_1_tube_1ac33744367c5632c9b6b6b919fc1c03f9" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type>int</type>
        <definition>int tubex::Tube::size</definition>
        <argsstring>() const</argsstring>
        <name>size</name>
        <reimplements refid="classtubex_1_1_dynamical_item_1aba900da1e407d079f805790e7a733166">size</reimplements>
        <briefdescription>
<para>Returns the dimension of the scalar tube (always 1) </para>        </briefdescription>
        <detaileddescription>
<para><simplesect kind="return"><para>1 </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/simon/tubex-lib/src/core/dynamics/tube/tubex_Tube.h" line="184" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classtubex_1_1_tube_1aaecfc3d1ebc5d4ca0a88d65ea2349015" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>const <ref refid="classtubex_1_1_tube" kindref="compound">Tube</ref></type>
        <definition>const Tube tubex::Tube::primitive</definition>
        <argsstring>(const ibex::Interval &amp;c=ibex::Interval(0.)) const</argsstring>
        <name>primitive</name>
        <param>
          <type>const ibex::Interval &amp;</type>
          <declname>c</declname>
          <defval>ibex::Interval(0.)</defval>
        </param>
        <briefdescription>
<para>Returns the primitive <ref refid="classtubex_1_1_tube" kindref="compound">Tube</ref> of this tube. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>c</parametername>
</parameternamelist>
<parameterdescription>
<para>the constant of integration (0. by default) </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>a new <ref refid="classtubex_1_1_tube" kindref="compound">Tube</ref> object with same slicing, enclosing the feasible primitives of this tube </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/simon/tubex-lib/src/core/dynamics/tube/tubex_Tube.h" line="192" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classtubex_1_1_tube_1a506093e88fd27ccebca375a54ade22af" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>const <ref refid="classtubex_1_1_tube" kindref="compound">Tube</ref> &amp;</type>
        <definition>const Tube&amp; tubex::Tube::operator=</definition>
        <argsstring>(const Tube &amp;x)</argsstring>
        <name>operator=</name>
        <param>
          <type>const <ref refid="classtubex_1_1_tube" kindref="compound">Tube</ref> &amp;</type>
          <declname>x</declname>
        </param>
        <briefdescription>
<para>Returns a copy of a <ref refid="classtubex_1_1_tube" kindref="compound">Tube</ref>. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>x</parametername>
</parameternamelist>
<parameterdescription>
<para>the <ref refid="classtubex_1_1_tube" kindref="compound">Tube</ref> object to be copied </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>a new <ref refid="classtubex_1_1_tube" kindref="compound">Tube</ref> object with same slicing and values </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/simon/tubex-lib/src/core/dynamics/tube/tubex_Tube.h" line="200" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classtubex_1_1_tube_1a6bc9d8e66761fd3a69e2907a9cd85efc" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type>const ibex::Interval</type>
        <definition>const ibex::Interval tubex::Tube::tdomain</definition>
        <argsstring>() const</argsstring>
        <name>tdomain</name>
        <reimplements refid="classtubex_1_1_dynamical_item_1abc5c8b18faab98d8101e3702ae0ee5f6">tdomain</reimplements>
        <briefdescription>
<para>Returns the temporal definition domain of this tube. </para>        </briefdescription>
        <detaileddescription>
<para><simplesect kind="return"><para>an Interval object <formula id="175">$[t_0,t_f]$</formula> </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/simon/tubex-lib/src/core/dynamics/tube/tubex_Tube.h" line="207" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classtubex_1_1_tube_1a152083473005e3d8fe6d0e75b658ee08" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>const Polygon</type>
        <definition>const Polygon tubex::Tube::polygon_envelope</definition>
        <argsstring>() const</argsstring>
        <name>polygon_envelope</name>
        <briefdescription>
<para>Returns the polygon envelope of this tube. </para>        </briefdescription>
        <detaileddescription>
<para><simplesect kind="return"><para>a Polygon object enclosing the slices </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/simon/tubex-lib/src/core/dynamics/tube/tubex_Tube.h" line="214" column="1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="user-defined">
      <header>Slices structure</header>
      <memberdef kind="function" id="classtubex_1_1_tube_1a67170647c4b88a6f9db567c1af3424bb" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int tubex::Tube::nb_slices</definition>
        <argsstring>() const</argsstring>
        <name>nb_slices</name>
        <briefdescription>
<para>Returns the number of slices of this tube. </para>        </briefdescription>
        <detaileddescription>
<para><anchor id="classtubex_1_1_tube_1DOC__TUBE_NB_SLICES"/> <simplesect kind="return"><para>an integer </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/simon/tubex-lib/src/core/dynamics/tube/tubex_Tube.h" line="226" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classtubex_1_1_tube_1a516e9785b96b1e1c7157cead95dbe025" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classtubex_1_1_slice" kindref="compound">Slice</ref> *</type>
        <definition>Slice* tubex::Tube::slice</definition>
        <argsstring>(int slice_id)</argsstring>
        <name>slice</name>
        <param>
          <type>int</type>
          <declname>slice_id</declname>
        </param>
        <briefdescription>
<para>Returns a pointer to the ith <ref refid="classtubex_1_1_slice" kindref="compound">Slice</ref> object of this tube. </para>        </briefdescription>
        <detaileddescription>
<para><anchor id="classtubex_1_1_tube_1DOC__TUBE_SLICE_INT"/> <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>slice_id</parametername>
</parameternamelist>
<parameterdescription>
<para>the index of the ith <ref refid="classtubex_1_1_slice" kindref="compound">Slice</ref> </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>a pointer to the corresponding <ref refid="classtubex_1_1_slice" kindref="compound">Slice</ref> </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/simon/tubex-lib/src/core/dynamics/tube/tubex_Tube.h" line="235" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classtubex_1_1_tube_1a5b9a37448fd24c00d20979b8b508eee4" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>const <ref refid="classtubex_1_1_slice" kindref="compound">Slice</ref> *</type>
        <definition>const Slice* tubex::Tube::slice</definition>
        <argsstring>(int slice_id) const</argsstring>
        <name>slice</name>
        <param>
          <type>int</type>
          <declname>slice_id</declname>
        </param>
        <briefdescription>
<para>Returns a constant pointer to the ith <ref refid="classtubex_1_1_slice" kindref="compound">Slice</ref> object of this tube. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>slice_id</parametername>
</parameternamelist>
<parameterdescription>
<para>the index of the ith <ref refid="classtubex_1_1_slice" kindref="compound">Slice</ref> </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>a const pointer to the corresponding <ref refid="classtubex_1_1_slice" kindref="compound">Slice</ref> </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/simon/tubex-lib/src/core/dynamics/tube/tubex_Tube.h" line="243" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classtubex_1_1_tube_1a7af6ac2e557256be168186a6731fb431" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classtubex_1_1_slice" kindref="compound">Slice</ref> *</type>
        <definition>Slice* tubex::Tube::slice</definition>
        <argsstring>(double t)</argsstring>
        <name>slice</name>
        <param>
          <type>double</type>
          <declname>t</declname>
        </param>
        <briefdescription>
<para>Returns a pointer to the <ref refid="classtubex_1_1_slice" kindref="compound">Slice</ref> object of this tube that is defined at <formula id="140">$t$</formula>. </para>        </briefdescription>
        <detaileddescription>
<para><anchor id="classtubex_1_1_tube_1DOC__TUBE_SLICE_DOUBLE"/> <simplesect kind="note"><para>If two Slices are defined at <formula id="140">$t$</formula> (common tdomain), then the first <ref refid="classtubex_1_1_slice" kindref="compound">Slice</ref> is considered</para></simplesect>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>t</parametername>
</parameternamelist>
<parameterdescription>
<para>the temporal key (double, must belong to the <ref refid="classtubex_1_1_tube" kindref="compound">Tube</ref>&apos;s tdomain) </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>a pointer to the corresponding <ref refid="classtubex_1_1_slice" kindref="compound">Slice</ref> </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/simon/tubex-lib/src/core/dynamics/tube/tubex_Tube.h" line="255" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classtubex_1_1_tube_1a9192742ad6c98ed41ab53542c6f3a7cb" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>const <ref refid="classtubex_1_1_slice" kindref="compound">Slice</ref> *</type>
        <definition>const Slice* tubex::Tube::slice</definition>
        <argsstring>(double t) const</argsstring>
        <name>slice</name>
        <param>
          <type>double</type>
          <declname>t</declname>
        </param>
        <briefdescription>
<para>Returns a constant pointer to the <ref refid="classtubex_1_1_slice" kindref="compound">Slice</ref> object of this tube that is defined at <formula id="140">$t$</formula>. </para>        </briefdescription>
        <detaileddescription>
<para><simplesect kind="note"><para>If two Slices are defined at <formula id="140">$t$</formula> (common tdomain), then the first <ref refid="classtubex_1_1_slice" kindref="compound">Slice</ref> is considered</para></simplesect>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>t</parametername>
</parameternamelist>
<parameterdescription>
<para>the temporal key (double, must belong to the <ref refid="classtubex_1_1_tube" kindref="compound">Tube</ref>&apos;s tdomain) </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>a const pointer to the corresponding <ref refid="classtubex_1_1_slice" kindref="compound">Slice</ref> </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/simon/tubex-lib/src/core/dynamics/tube/tubex_Tube.h" line="266" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classtubex_1_1_tube_1aefff51e3f14ff342abdf5add61983732" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classtubex_1_1_slice" kindref="compound">Slice</ref> *</type>
        <definition>Slice* tubex::Tube::first_slice</definition>
        <argsstring>()</argsstring>
        <name>first_slice</name>
        <briefdescription>
<para>Returns a pointer to the first <ref refid="classtubex_1_1_slice" kindref="compound">Slice</ref> object of this tube. </para>        </briefdescription>
        <detaileddescription>
<para><simplesect kind="return"><para>a pointer to the corresponding <ref refid="classtubex_1_1_slice" kindref="compound">Slice</ref> </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/simon/tubex-lib/src/core/dynamics/tube/tubex_Tube.h" line="273" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classtubex_1_1_tube_1ad220ef2076f25e3cc623b93c0e21e280" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>const <ref refid="classtubex_1_1_slice" kindref="compound">Slice</ref> *</type>
        <definition>const Slice* tubex::Tube::first_slice</definition>
        <argsstring>() const</argsstring>
        <name>first_slice</name>
        <briefdescription>
<para>Returns a constant pointer to the first <ref refid="classtubex_1_1_slice" kindref="compound">Slice</ref> object of this tube. </para>        </briefdescription>
        <detaileddescription>
<para><simplesect kind="return"><para>a const pointer to the corresponding <ref refid="classtubex_1_1_slice" kindref="compound">Slice</ref> </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/simon/tubex-lib/src/core/dynamics/tube/tubex_Tube.h" line="280" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classtubex_1_1_tube_1aed886d0fb0cdf6510420d45bdd8dede6" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classtubex_1_1_slice" kindref="compound">Slice</ref> *</type>
        <definition>Slice* tubex::Tube::last_slice</definition>
        <argsstring>()</argsstring>
        <name>last_slice</name>
        <briefdescription>
<para>Returns a pointer to the last <ref refid="classtubex_1_1_slice" kindref="compound">Slice</ref> object of this tube. </para>        </briefdescription>
        <detaileddescription>
<para><simplesect kind="return"><para>a pointer to the corresponding <ref refid="classtubex_1_1_slice" kindref="compound">Slice</ref> </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/simon/tubex-lib/src/core/dynamics/tube/tubex_Tube.h" line="287" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classtubex_1_1_tube_1a2f68de044f4a9e52b13146b1fbe92d45" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>const <ref refid="classtubex_1_1_slice" kindref="compound">Slice</ref> *</type>
        <definition>const Slice* tubex::Tube::last_slice</definition>
        <argsstring>() const</argsstring>
        <name>last_slice</name>
        <briefdescription>
<para>Returns a constant pointer to the last <ref refid="classtubex_1_1_slice" kindref="compound">Slice</ref> object of this tube. </para>        </briefdescription>
        <detaileddescription>
<para><simplesect kind="return"><para>a const pointer to the corresponding <ref refid="classtubex_1_1_slice" kindref="compound">Slice</ref> </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/simon/tubex-lib/src/core/dynamics/tube/tubex_Tube.h" line="294" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classtubex_1_1_tube_1a1c7ec454c5338ff613beee4ee7f85f81" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classtubex_1_1_slice" kindref="compound">Slice</ref> *</type>
        <definition>Slice* tubex::Tube::wider_slice</definition>
        <argsstring>()</argsstring>
        <name>wider_slice</name>
        <briefdescription>
<para>Returns a pointer to the <ref refid="classtubex_1_1_slice" kindref="compound">Slice</ref> defined over the wider temporal domain. </para>        </briefdescription>
        <detaileddescription>
<para><simplesect kind="note"><para>If two <ref refid="classtubex_1_1_slice" kindref="compound">Slice</ref> objects have the same tdomain width, then the first one is considered</para></simplesect>
<simplesect kind="return"><para>a pointer to the corresponding <ref refid="classtubex_1_1_slice" kindref="compound">Slice</ref> </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/simon/tubex-lib/src/core/dynamics/tube/tubex_Tube.h" line="303" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classtubex_1_1_tube_1aeb614c52143b053e374bb9a6a3821225" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>const <ref refid="classtubex_1_1_slice" kindref="compound">Slice</ref> *</type>
        <definition>const Slice* tubex::Tube::wider_slice</definition>
        <argsstring>() const</argsstring>
        <name>wider_slice</name>
        <briefdescription>
<para>Returns a constant pointer to the <ref refid="classtubex_1_1_slice" kindref="compound">Slice</ref> defined over the wider temporal domain. </para>        </briefdescription>
        <detaileddescription>
<para><simplesect kind="note"><para>If two <ref refid="classtubex_1_1_slice" kindref="compound">Slice</ref> objects have the same tdomain width, then the first one is considered</para></simplesect>
<simplesect kind="return"><para>a const pointer to the corresponding <ref refid="classtubex_1_1_slice" kindref="compound">Slice</ref> </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/simon/tubex-lib/src/core/dynamics/tube/tubex_Tube.h" line="312" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classtubex_1_1_tube_1a4e6c7476fb3039cc23c63a9cd0e7da9a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classtubex_1_1_slice" kindref="compound">Slice</ref> *</type>
        <definition>Slice* tubex::Tube::largest_slice</definition>
        <argsstring>()</argsstring>
        <name>largest_slice</name>
        <briefdescription>
<para>Returns a pointer to the <ref refid="classtubex_1_1_slice" kindref="compound">Slice</ref> object of this tube for which the interval value is the more uncertain. </para>        </briefdescription>
        <detaileddescription>
<para><simplesect kind="return"><para>a pointer to the corresponding <ref refid="classtubex_1_1_slice" kindref="compound">Slice</ref> </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/simon/tubex-lib/src/core/dynamics/tube/tubex_Tube.h" line="320" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classtubex_1_1_tube_1a70a61d72421a43b92f6f31cdbf36af7f" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>const <ref refid="classtubex_1_1_slice" kindref="compound">Slice</ref> *</type>
        <definition>const Slice* tubex::Tube::largest_slice</definition>
        <argsstring>() const</argsstring>
        <name>largest_slice</name>
        <briefdescription>
<para>Returns a constant pointer to the <ref refid="classtubex_1_1_slice" kindref="compound">Slice</ref> object of this tube for which the interval value is the more uncertain. </para>        </briefdescription>
        <detaileddescription>
<para><simplesect kind="return"><para>a const pointer to the corresponding <ref refid="classtubex_1_1_slice" kindref="compound">Slice</ref> </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/simon/tubex-lib/src/core/dynamics/tube/tubex_Tube.h" line="328" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classtubex_1_1_tube_1acf511e5e9f2bb71588112a9ed05a5f6c" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>const ibex::Interval</type>
        <definition>const ibex::Interval tubex::Tube::slice_tdomain</definition>
        <argsstring>(int slice_id) const</argsstring>
        <name>slice_tdomain</name>
        <param>
          <type>int</type>
          <declname>slice_id</declname>
        </param>
        <briefdescription>
<para>Returns the temporal definition domain of the ith <ref refid="classtubex_1_1_slice" kindref="compound">Slice</ref> of this tube. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>slice_id</parametername>
</parameternamelist>
<parameterdescription>
<para>the index of the ith <ref refid="classtubex_1_1_slice" kindref="compound">Slice</ref> </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>an Interval object <formula id="260">$[t_0^i,t_f^i]$</formula> </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/simon/tubex-lib/src/core/dynamics/tube/tubex_Tube.h" line="336" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classtubex_1_1_tube_1ab05beac4591a5d692466ab7fb38a2250" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int tubex::Tube::input2index</definition>
        <argsstring>(double t) const</argsstring>
        <name>input2index</name>
        <param>
          <type>double</type>
          <declname>t</declname>
        </param>
        <briefdescription>
<para>Returns the <ref refid="classtubex_1_1_slice" kindref="compound">Slice</ref> index related to the temporal key <formula id="140">$t$</formula>. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>t</parametername>
</parameternamelist>
<parameterdescription>
<para>the temporal key (double, must belong to the <ref refid="classtubex_1_1_tube" kindref="compound">Tube</ref>&apos;s tdomain) </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>an integer </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/simon/tubex-lib/src/core/dynamics/tube/tubex_Tube.h" line="344" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classtubex_1_1_tube_1a1fe517f4eff444d72b2d6a5d682a8086" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int tubex::Tube::index</definition>
        <argsstring>(const Slice *slice) const</argsstring>
        <name>index</name>
        <param>
          <type>const <ref refid="classtubex_1_1_slice" kindref="compound">Slice</ref> *</type>
          <declname>slice</declname>
        </param>
        <briefdescription>
<para>Returns the <ref refid="classtubex_1_1_slice" kindref="compound">Slice</ref> index related to the <ref refid="classtubex_1_1_slice" kindref="compound">Slice</ref> pointer. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>slice</parametername>
</parameternamelist>
<parameterdescription>
<para>a const pointer to a <ref refid="classtubex_1_1_slice" kindref="compound">Slice</ref> object of this tube </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>an integer </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/simon/tubex-lib/src/core/dynamics/tube/tubex_Tube.h" line="352" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classtubex_1_1_tube_1a98f8819bd664504a4dd1e9f85e352478" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void tubex::Tube::sample</definition>
        <argsstring>(double t)</argsstring>
        <name>sample</name>
        <param>
          <type>double</type>
          <declname>t</declname>
        </param>
        <briefdescription>
<para>Samples this tube at <formula id="140">$t$</formula>. </para>        </briefdescription>
        <detaileddescription>
<para><simplesect kind="note"><para>Without any effect if two <ref refid="classtubex_1_1_slice" kindref="compound">Slice</ref> objects are already defined at <formula id="140">$t$</formula> (if the gate <formula id="261">$[x](t)$</formula> already exists)</para></simplesect>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>t</parametername>
</parameternamelist>
<parameterdescription>
<para>the temporal key (double, must belong to the <ref refid="classtubex_1_1_tube" kindref="compound">Tube</ref>&apos;s tdomain) </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/simon/tubex-lib/src/core/dynamics/tube/tubex_Tube.h" line="363" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classtubex_1_1_tube_1abe1856d09554df0722c2baff34b45170" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void tubex::Tube::sample</definition>
        <argsstring>(double t, Slice *slice_to_be_sampled)</argsstring>
        <name>sample</name>
        <param>
          <type>double</type>
          <declname>t</declname>
        </param>
        <param>
          <type><ref refid="classtubex_1_1_slice" kindref="compound">Slice</ref> *</type>
          <declname>slice_to_be_sampled</declname>
        </param>
        <briefdescription>
<para>Samples this tube at <formula id="140">$t$</formula> from a pointer to the corresponding slice. </para>        </briefdescription>
        <detaileddescription>
<para><anchor id="classtubex_1_1_tube_1DOC__TUBE_SAMPLE_DOUBLE_SLICE"/> Reduces the complexity of related methods by providing a direct access to the <ref refid="classtubex_1_1_slice" kindref="compound">Slice</ref> object covering the input <formula id="140">$t$</formula>.</para><para><simplesect kind="note"><para>Without any effect if two <ref refid="classtubex_1_1_slice" kindref="compound">Slice</ref> objects are already defined at <formula id="140">$t$</formula> (if the gate <formula id="261">$[x](t)$</formula> already exists)</para></simplesect>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>t</parametername>
</parameternamelist>
<parameterdescription>
<para>the temporal key (double, must belong to the <ref refid="classtubex_1_1_tube" kindref="compound">Tube</ref>&apos;s tdomain) </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>slice_to_be_sampled</parametername>
</parameternamelist>
<parameterdescription>
<para>a pointer to the <ref refid="classtubex_1_1_slice" kindref="compound">Slice</ref> whose tdomain contains <formula id="140">$t$</formula> </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/simon/tubex-lib/src/core/dynamics/tube/tubex_Tube.h" line="378" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classtubex_1_1_tube_1a4c6b506b8761f731ebb2cb4277070a66" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void tubex::Tube::sample</definition>
        <argsstring>(double t, const ibex::Interval &amp;gate)</argsstring>
        <name>sample</name>
        <param>
          <type>double</type>
          <declname>t</declname>
        </param>
        <param>
          <type>const ibex::Interval &amp;</type>
          <declname>gate</declname>
        </param>
        <briefdescription>
<para>Samples this tube at <formula id="140">$t$</formula> with a specific gate value. </para>        </briefdescription>
        <detaileddescription>
<para><simplesect kind="note"><para>Without any sampling effect if two <ref refid="classtubex_1_1_slice" kindref="compound">Slice</ref> objects are already defined at <formula id="140">$t$</formula> (if the gate <formula id="261">$[x](t)$</formula> already exists)</para></simplesect>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>t</parametername>
</parameternamelist>
<parameterdescription>
<para>the temporal key (double, must belong to the <ref refid="classtubex_1_1_tube" kindref="compound">Tube</ref>&apos;s tdomain) </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>gate</parametername>
</parameternamelist>
<parameterdescription>
<para>the Interval value of this tube at <formula id="140">$t$</formula> </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/simon/tubex-lib/src/core/dynamics/tube/tubex_Tube.h" line="389" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classtubex_1_1_tube_1ab19a4eade55e650dcd20867912528742" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void tubex::Tube::sample</definition>
        <argsstring>(const Tube &amp;x)</argsstring>
        <name>sample</name>
        <param>
          <type>const <ref refid="classtubex_1_1_tube" kindref="compound">Tube</ref> &amp;</type>
          <declname>x</declname>
        </param>
        <briefdescription>
<para>Samples this tube so that it will share the same sampling of <formula id="77">$[x](\cdot)$</formula>. </para>        </briefdescription>
        <detaileddescription>
<para><simplesect kind="note"><para>The previous sampling of this tube is preserved</para></simplesect>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>x</parametername>
</parameternamelist>
<parameterdescription>
<para>the <ref refid="classtubex_1_1_tube" kindref="compound">Tube</ref> from which the new sampling will come from </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/simon/tubex-lib/src/core/dynamics/tube/tubex_Tube.h" line="398" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classtubex_1_1_tube_1a61dbcbd96c4122d34f4dfa703956a258" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool tubex::Tube::gate_exists</definition>
        <argsstring>(double t) const</argsstring>
        <name>gate_exists</name>
        <param>
          <type>double</type>
          <declname>t</declname>
        </param>
        <briefdescription>
<para>Tests if a gate exists at time <formula id="140">$t$</formula>. </para>        </briefdescription>
        <detaileddescription>
<para><anchor id="classtubex_1_1_tube_1DOC__TUBE_GATE_EXISTS_T"/> <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>t</parametername>
</parameternamelist>
<parameterdescription>
<para>time input to test </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para><computeroutput>true</computeroutput> if a gate exists </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/simon/tubex-lib/src/core/dynamics/tube/tubex_Tube.h" line="407" column="1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="user-defined">
      <header>Accessing values</header>
      <memberdef kind="function" id="classtubex_1_1_tube_1ab4e7b71c6fdd0a80603abfca5df37afd" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>const ibex::Interval</type>
        <definition>const ibex::Interval tubex::Tube::codomain</definition>
        <argsstring>() const</argsstring>
        <name>codomain</name>
        <briefdescription>
<para>Returns the interval of feasible values. </para>        </briefdescription>
        <detaileddescription>
<para><simplesect kind="return"><para>an Interval object <formula id="262">$[x]([t_0,t_f])$</formula> </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/simon/tubex-lib/src/core/dynamics/tube/tubex_Tube.h" line="418" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classtubex_1_1_tube_1ace62e25555cd3367bf2aa08373560784" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>double</type>
        <definition>double tubex::Tube::volume</definition>
        <argsstring>() const</argsstring>
        <name>volume</name>
        <briefdescription>
<para>Returns the volume of this tube. </para>        </briefdescription>
        <detaileddescription>
<para><simplesect kind="note"><para>returns POS_INFINITY if the codomain is unbounded </para></simplesect>
<simplesect kind="note"><para>returns 0 if the tube is flat (and so without wrapping effect)</para></simplesect>
<simplesect kind="return"><para>volume defined as <formula id="263">$w([t_0,t_f])\times w([x]([t_0,t_f]))$</formula> </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/simon/tubex-lib/src/core/dynamics/tube/tubex_Tube.h" line="428" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classtubex_1_1_tube_1acca046c9cdc721482d81369af865fcf7" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>const ibex::Interval</type>
        <definition>const ibex::Interval tubex::Tube::operator()</definition>
        <argsstring>(int slice_id) const</argsstring>
        <name>operator()</name>
        <param>
          <type>int</type>
          <declname>slice_id</declname>
        </param>
        <briefdescription>
<para>Returns the value of the ith slice. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>slice_id</parametername>
</parameternamelist>
<parameterdescription>
<para>the index of the ith slice </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Interval value of <formula id="264">$[x](i)$</formula> </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/simon/tubex-lib/src/core/dynamics/tube/tubex_Tube.h" line="436" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classtubex_1_1_tube_1abd3fdbd49b6c37ce126a39859093345f" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>const ibex::Interval</type>
        <definition>const ibex::Interval tubex::Tube::operator()</definition>
        <argsstring>(double t) const</argsstring>
        <name>operator()</name>
        <param>
          <type>double</type>
          <declname>t</declname>
        </param>
        <briefdescription>
<para>Returns the evaluation of this tube at <formula id="140">$t$</formula>. </para>        </briefdescription>
        <detaileddescription>
<para><anchor id="classtubex_1_1_tube_1DOC__TUBE_OPERATOR_DOUBLE_T"/> <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>t</parametername>
</parameternamelist>
<parameterdescription>
<para>the temporal key (double, must belong to the <ref refid="classtubex_1_1_tube" kindref="compound">Tube</ref>&apos;s tdomain) </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Interval value of <formula id="261">$[x](t)$</formula> </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/simon/tubex-lib/src/core/dynamics/tube/tubex_Tube.h" line="445" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classtubex_1_1_tube_1af144d12fb5730bbf2ce81b762aaa1e49" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>const ibex::Interval</type>
        <definition>const ibex::Interval tubex::Tube::operator()</definition>
        <argsstring>(const ibex::Interval &amp;t) const</argsstring>
        <name>operator()</name>
        <param>
          <type>const ibex::Interval &amp;</type>
          <declname>t</declname>
        </param>
        <briefdescription>
<para>Returns the interval evaluation of this tube over <formula id="174">$[t]$</formula>. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>t</parametername>
</parameternamelist>
<parameterdescription>
<para>the subtdomain (Interval, must be a subset of the <ref refid="classtubex_1_1_tube" kindref="compound">Tube</ref>&apos;s tdomain) </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Interval envelope <formula id="265">$[x]([t])$</formula> </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/simon/tubex-lib/src/core/dynamics/tube/tubex_Tube.h" line="453" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classtubex_1_1_tube_1aba59999b9058969b74456eeb2d247253" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>const std::pair&lt; ibex::Interval, ibex::Interval &gt;</type>
        <definition>const std::pair&lt;ibex::Interval,ibex::Interval&gt; tubex::Tube::eval</definition>
        <argsstring>(const ibex::Interval &amp;t=ibex::Interval::ALL_REALS) const</argsstring>
        <name>eval</name>
        <param>
          <type>const ibex::Interval &amp;</type>
          <declname>t</declname>
          <defval>ibex::Interval::ALL_REALS</defval>
        </param>
        <briefdescription>
<para>Returns the interval evaluations of the bounds of the tube <formula id="266">$\underline{x^-}(\cdot)$</formula> and <formula id="267">$\overline{x^+}(\cdot)$</formula> over <formula id="174">$[t]$</formula>. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>t</parametername>
</parameternamelist>
<parameterdescription>
<para>the subtdomain (Interval, must be a subset of the <ref refid="classtubex_1_1_tube" kindref="compound">Tube</ref>&apos;s tdomain) </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>the pair <formula id="268">$\big([\underline{x^-}]([t]),[\overline{x^+}]([t])\big)$</formula> </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/simon/tubex-lib/src/core/dynamics/tube/tubex_Tube.h" line="462" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classtubex_1_1_tube_1a0ad03bafee1a07b25e57bcb71e2717b0" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>const ibex::Interval</type>
        <definition>const ibex::Interval tubex::Tube::interpol</definition>
        <argsstring>(double t, const Tube &amp;v) const</argsstring>
        <name>interpol</name>
        <param>
          <type>double</type>
          <declname>t</declname>
        </param>
        <param>
          <type>const <ref refid="classtubex_1_1_tube" kindref="compound">Tube</ref> &amp;</type>
          <declname>v</declname>
        </param>
        <briefdescription>
<para>Returns the optimal evaluation of this tube at <formula id="140">$t$</formula>, based on the derivative information <formula id="225">$\dot{x}(\cdot)$</formula>. </para>        </briefdescription>
        <detaileddescription>
<para><xrefsect id="todo_1_todo000006"><xreftitle>Todo</xreftitle><xrefdescription><para>Change the name of this method?</para></xrefdescription></xrefsect></para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>t</parametername>
</parameternamelist>
<parameterdescription>
<para>the temporal key (double, must belong to the <ref refid="classtubex_1_1_tube" kindref="compound">Tube</ref>&apos;s tdomain) </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>v</parametername>
</parameternamelist>
<parameterdescription>
<para>the derivative tube such that <formula id="269">$\dot{x}(\cdot)\in[v](\cdot)$</formula> </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Interval value of <formula id="261">$[x](t)$</formula> </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/simon/tubex-lib/src/core/dynamics/tube/tubex_Tube.h" line="474" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classtubex_1_1_tube_1a9f8f9e7d1a23dc299cd1b09c5d65e89b" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>const ibex::Interval</type>
        <definition>const ibex::Interval tubex::Tube::interpol</definition>
        <argsstring>(const ibex::Interval &amp;t, const Tube &amp;v) const</argsstring>
        <name>interpol</name>
        <param>
          <type>const ibex::Interval &amp;</type>
          <declname>t</declname>
        </param>
        <param>
          <type>const <ref refid="classtubex_1_1_tube" kindref="compound">Tube</ref> &amp;</type>
          <declname>v</declname>
        </param>
        <briefdescription>
<para>Returns the optimal interval evaluation of this tube over <formula id="174">$[t]$</formula>, based on the derivative information <formula id="225">$\dot{x}(\cdot)$</formula>. </para>        </briefdescription>
        <detaileddescription>
<para><xrefsect id="todo_1_todo000007"><xreftitle>Todo</xreftitle><xrefdescription><para>Change the name of this method?</para></xrefdescription></xrefsect></para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>t</parametername>
</parameternamelist>
<parameterdescription>
<para>the subtdomain (Interval, must be a subset of the <ref refid="classtubex_1_1_tube" kindref="compound">Tube</ref>&apos;s tdomain) </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>v</parametername>
</parameternamelist>
<parameterdescription>
<para>the derivative tube such that <formula id="269">$\dot{x}(\cdot)\in[v](\cdot)$</formula> </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Interval value of <formula id="265">$[x]([t])$</formula> </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/simon/tubex-lib/src/core/dynamics/tube/tubex_Tube.h" line="486" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classtubex_1_1_tube_1a1ec2b9cb1f6270fc6a6dff0b5e888d1e" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>const ibex::Interval</type>
        <definition>const ibex::Interval tubex::Tube::invert</definition>
        <argsstring>(const ibex::Interval &amp;y, const ibex::Interval &amp;search_tdomain=ibex::Interval::ALL_REALS) const</argsstring>
        <name>invert</name>
        <param>
          <type>const ibex::Interval &amp;</type>
          <declname>y</declname>
        </param>
        <param>
          <type>const ibex::Interval &amp;</type>
          <declname>search_tdomain</declname>
          <defval>ibex::Interval::ALL_REALS</defval>
        </param>
        <briefdescription>
<para>Returns the interval inversion <formula id="270">$[x]^{-1}([y])$</formula>. </para>        </briefdescription>
        <detaileddescription>
<para><simplesect kind="note"><para>If the inversion results in several pre-images, their union is returned</para></simplesect>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>y</parametername>
</parameternamelist>
<parameterdescription>
<para>the interval codomain </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>search_tdomain</parametername>
</parameternamelist>
<parameterdescription>
<para>the optional temporal domain on which the inversion will be performed </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>the hull of <formula id="270">$[x]^{-1}([y])$</formula> </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/simon/tubex-lib/src/core/dynamics/tube/tubex_Tube.h" line="497" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classtubex_1_1_tube_1a4cc01a70753a0cd19672f947275bfdda" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void tubex::Tube::invert</definition>
        <argsstring>(const ibex::Interval &amp;y, std::vector&lt; ibex::Interval &gt; &amp;v_t, const ibex::Interval &amp;search_tdomain=ibex::Interval::ALL_REALS) const</argsstring>
        <name>invert</name>
        <param>
          <type>const ibex::Interval &amp;</type>
          <declname>y</declname>
        </param>
        <param>
          <type>std::vector&lt; ibex::Interval &gt; &amp;</type>
          <declname>v_t</declname>
        </param>
        <param>
          <type>const ibex::Interval &amp;</type>
          <declname>search_tdomain</declname>
          <defval>ibex::Interval::ALL_REALS</defval>
        </param>
        <briefdescription>
<para>Computes the set of continuous values of the inversion <formula id="270">$[x]^{-1}([y])$</formula>. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>y</parametername>
</parameternamelist>
<parameterdescription>
<para>the interval codomain </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>v_t</parametername>
</parameternamelist>
<parameterdescription>
<para>the vector of the sub-tdomains <formula id="271">$[t_k]$</formula> for which <formula id="272">$\forall t\in[t_k] \mid x(t)\in[y], x(\cdot)\in[x](\cdot)$</formula> </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>search_tdomain</parametername>
</parameternamelist>
<parameterdescription>
<para>the optional temporal domain on which the inversion will be performed </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/simon/tubex-lib/src/core/dynamics/tube/tubex_Tube.h" line="507" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classtubex_1_1_tube_1a5f3132df3ec3d23435913f3ae8549c6e" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>const ibex::Interval</type>
        <definition>const ibex::Interval tubex::Tube::invert</definition>
        <argsstring>(const ibex::Interval &amp;y, const Tube &amp;v, const ibex::Interval &amp;search_tdomain=ibex::Interval::ALL_REALS) const</argsstring>
        <name>invert</name>
        <param>
          <type>const ibex::Interval &amp;</type>
          <declname>y</declname>
        </param>
        <param>
          <type>const <ref refid="classtubex_1_1_tube" kindref="compound">Tube</ref> &amp;</type>
          <declname>v</declname>
        </param>
        <param>
          <type>const ibex::Interval &amp;</type>
          <declname>search_tdomain</declname>
          <defval>ibex::Interval::ALL_REALS</defval>
        </param>
        <briefdescription>
<para>Returns the optimal interval inversion <formula id="270">$[x]^{-1}([y])$</formula>. </para>        </briefdescription>
        <detaileddescription>
<para><simplesect kind="note"><para>The knowledge of the derivative tube <formula id="161">$[v](\cdot)$</formula> allows a finer inversion </para></simplesect>
<simplesect kind="note"><para>If the inversion results in several pre-images, their union is returned</para></simplesect>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>y</parametername>
</parameternamelist>
<parameterdescription>
<para>the interval codomain </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>v</parametername>
</parameternamelist>
<parameterdescription>
<para>the derivative tube such that <formula id="269">$\dot{x}(\cdot)\in[v](\cdot)$</formula> </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>search_tdomain</parametername>
</parameternamelist>
<parameterdescription>
<para>the optional temporal domain on which the inversion will be performed </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>the hull of <formula id="270">$[x]^{-1}([y])$</formula> </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/simon/tubex-lib/src/core/dynamics/tube/tubex_Tube.h" line="520" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classtubex_1_1_tube_1a7d0b112a5833043bc3a80627e43ad90c" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void tubex::Tube::invert</definition>
        <argsstring>(const ibex::Interval &amp;y, std::vector&lt; ibex::Interval &gt; &amp;v_t, const Tube &amp;v, const ibex::Interval &amp;search_tdomain=ibex::Interval::ALL_REALS) const</argsstring>
        <name>invert</name>
        <param>
          <type>const ibex::Interval &amp;</type>
          <declname>y</declname>
        </param>
        <param>
          <type>std::vector&lt; ibex::Interval &gt; &amp;</type>
          <declname>v_t</declname>
        </param>
        <param>
          <type>const <ref refid="classtubex_1_1_tube" kindref="compound">Tube</ref> &amp;</type>
          <declname>v</declname>
        </param>
        <param>
          <type>const ibex::Interval &amp;</type>
          <declname>search_tdomain</declname>
          <defval>ibex::Interval::ALL_REALS</defval>
        </param>
        <briefdescription>
<para>Computes the set of continuous values of the optimal inversion <formula id="270">$[x]^{-1}([y])$</formula>. </para>        </briefdescription>
        <detaileddescription>
<para><anchor id="classtubex_1_1_tube_1DOC__TUBE_INVERT_INTERVAL_VECTOR_TUBE_INTERVAL"/> <simplesect kind="note"><para>The knowledge of the derivative tube <formula id="161">$[v](\cdot)$</formula> allows finer inversions</para></simplesect>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>y</parametername>
</parameternamelist>
<parameterdescription>
<para>the interval codomain </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>v_t</parametername>
</parameternamelist>
<parameterdescription>
<para>the vector of the sub-tdomains <formula id="271">$[t_k]$</formula> for which <formula id="273">$\exists t\in[t_k] \mid x(t)\in[y], x(\cdot)\in[x](\cdot), \dot{x}(\cdot)\in[v](\cdot)$</formula> </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>v</parametername>
</parameternamelist>
<parameterdescription>
<para>the derivative tube such that <formula id="269">$\dot{x}(\cdot)\in[v](\cdot)$</formula> </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>search_tdomain</parametername>
</parameternamelist>
<parameterdescription>
<para>the optional temporal domain on which the inversion will be performed </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/simon/tubex-lib/src/core/dynamics/tube/tubex_Tube.h" line="534" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classtubex_1_1_tube_1af3b1558e4e4246ffb22f5d2ad2fe773c" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>double</type>
        <definition>double tubex::Tube::max_diam</definition>
        <argsstring>() const</argsstring>
        <name>max_diam</name>
        <briefdescription>
<para>Returns the diameter of the interval value <formula id="261">$[x](t)$</formula> that is the more uncertain. </para>        </briefdescription>
        <detaileddescription>
<para><simplesect kind="return"><para>the maximal thickness of this tube </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/simon/tubex-lib/src/core/dynamics/tube/tubex_Tube.h" line="541" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classtubex_1_1_tube_1a67c3fb105bc8e208b927bfdc35343d4b" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>double</type>
        <definition>double tubex::Tube::max_gate_diam</definition>
        <argsstring>(double &amp;t) const</argsstring>
        <name>max_gate_diam</name>
        <param>
          <type>double &amp;</type>
          <declname>t</declname>
        </param>
        <briefdescription>
<para>Returns the diameter of the gate of this tube that is the more uncertain. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>t</parametername>
</parameternamelist>
<parameterdescription>
<para>the temporal key of the corresponding uncertain gate </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>the maximal thickness of the gate </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/simon/tubex-lib/src/core/dynamics/tube/tubex_Tube.h" line="549" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classtubex_1_1_tube_1ac4bc81546b23aec26497e79c5db4a689" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>const <ref refid="classtubex_1_1_trajectory" kindref="compound">Trajectory</ref></type>
        <definition>const Trajectory tubex::Tube::diam</definition>
        <argsstring>(bool gates_thicknesses=false) const</argsstring>
        <name>diam</name>
        <param>
          <type>bool</type>
          <declname>gates_thicknesses</declname>
          <defval>false</defval>
        </param>
        <briefdescription>
<para>Returns the diameters of the tube as a trajectory. </para>        </briefdescription>
        <detaileddescription>
<para><simplesect kind="note"><para>Without derivative knowledge, and because the tube is made of boxed slices, the trajectory will be discontinuous and so the returned object will not reliably represent the diameters. It can be mainly used for display purposes.</para></simplesect>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>gates_thicknesses</parametername>
</parameternamelist>
<parameterdescription>
<para>if true, the diameters of the gates will be evaluated too </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>the set of diameters associated to temporal inputs </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/simon/tubex-lib/src/core/dynamics/tube/tubex_Tube.h" line="561" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classtubex_1_1_tube_1ac714458ae0ef21b29115cf955e5b44c6" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>const <ref refid="classtubex_1_1_trajectory" kindref="compound">Trajectory</ref></type>
        <definition>const Trajectory tubex::Tube::diam</definition>
        <argsstring>(const Tube &amp;v) const</argsstring>
        <name>diam</name>
        <param>
          <type>const <ref refid="classtubex_1_1_tube" kindref="compound">Tube</ref> &amp;</type>
          <declname>v</declname>
        </param>
        <briefdescription>
<para>Returns the diameters of the tube as a trajectory. </para>        </briefdescription>
        <detaileddescription>
<para><simplesect kind="note"><para>Because the tube is made of boxed slices, the trajectory may be discontinuous and so the returned object will not reliably represent the diameters. It can be mainly used for display purposes.</para></simplesect>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>v</parametername>
</parameternamelist>
<parameterdescription>
<para>the derivative tube such that <formula id="269">$\dot{x}(\cdot)\in[v](\cdot)$</formula> </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>the set of diameters associated to temporal inputs </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/simon/tubex-lib/src/core/dynamics/tube/tubex_Tube.h" line="573" column="1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="user-defined">
      <header>Tests</header>
      <memberdef kind="function" id="classtubex_1_1_tube_1a826f648430569f48413bd5098aa04bbe" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool tubex::Tube::operator==</definition>
        <argsstring>(const Tube &amp;x) const</argsstring>
        <name>operator==</name>
        <param>
          <type>const <ref refid="classtubex_1_1_tube" kindref="compound">Tube</ref> &amp;</type>
          <declname>x</declname>
        </param>
        <briefdescription>
<para>Returns true if this tube is equal to <formula id="77">$[x](\cdot)$</formula>. </para>        </briefdescription>
        <detaileddescription>
<para><simplesect kind="note"><para>Equality is obtained if the tubes share the same bounds, tdomain and sampling</para></simplesect>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>x</parametername>
</parameternamelist>
<parameterdescription>
<para>the <ref refid="classtubex_1_1_tube" kindref="compound">Tube</ref> object </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>true in case of equality </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/simon/tubex-lib/src/core/dynamics/tube/tubex_Tube.h" line="588" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classtubex_1_1_tube_1a8f962dab50c033072d8a5f08e9f3b4e5" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool tubex::Tube::operator!=</definition>
        <argsstring>(const Tube &amp;x) const</argsstring>
        <name>operator!=</name>
        <param>
          <type>const <ref refid="classtubex_1_1_tube" kindref="compound">Tube</ref> &amp;</type>
          <declname>x</declname>
        </param>
        <briefdescription>
<para>Returns true if this tube is different from <formula id="77">$[x](\cdot)$</formula>. </para>        </briefdescription>
        <detaileddescription>
<para><simplesect kind="note"><para>The two tubes are different if they do not share the same bounds, tdomain or sampling</para></simplesect>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>x</parametername>
</parameternamelist>
<parameterdescription>
<para>the <ref refid="classtubex_1_1_tube" kindref="compound">Tube</ref> object </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>true in case of difference </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/simon/tubex-lib/src/core/dynamics/tube/tubex_Tube.h" line="599" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classtubex_1_1_tube_1a37002cbe9e60394c42f8c87f401a6d51" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool tubex::Tube::is_subset</definition>
        <argsstring>(const Tube &amp;x) const</argsstring>
        <name>is_subset</name>
        <param>
          <type>const <ref refid="classtubex_1_1_tube" kindref="compound">Tube</ref> &amp;</type>
          <declname>x</declname>
        </param>
        <briefdescription>
<para>Returns true if this tube is a subset of <formula id="77">$[x](\cdot)$</formula>. </para>        </briefdescription>
        <detaileddescription>
<para><simplesect kind="note"><para>The two tubes may not share the same slicing, but must have the same tdomain</para></simplesect>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>x</parametername>
</parameternamelist>
<parameterdescription>
<para>the <ref refid="classtubex_1_1_tube" kindref="compound">Tube</ref> object </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>true in case of subset </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/simon/tubex-lib/src/core/dynamics/tube/tubex_Tube.h" line="610" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classtubex_1_1_tube_1a7357b1f57a997286cf15a87cd60d03f9" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool tubex::Tube::is_strict_subset</definition>
        <argsstring>(const Tube &amp;x) const</argsstring>
        <name>is_strict_subset</name>
        <param>
          <type>const <ref refid="classtubex_1_1_tube" kindref="compound">Tube</ref> &amp;</type>
          <declname>x</declname>
        </param>
        <briefdescription>
<para>Returns true if this tube is a subset of <formula id="77">$[x](\cdot)$</formula>, and not <formula id="77">$[x](\cdot)$</formula> itself. </para>        </briefdescription>
        <detaileddescription>
<para><simplesect kind="note"><para>The two tubes may not share the same slicing, but must have the same tdomain</para></simplesect>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>x</parametername>
</parameternamelist>
<parameterdescription>
<para>the <ref refid="classtubex_1_1_tube" kindref="compound">Tube</ref> object </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>true in case of strict subset </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/simon/tubex-lib/src/core/dynamics/tube/tubex_Tube.h" line="622" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classtubex_1_1_tube_1a7c4e138008e222c131d53a55dee6adb1" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool tubex::Tube::is_interior_subset</definition>
        <argsstring>(const Tube &amp;x) const</argsstring>
        <name>is_interior_subset</name>
        <param>
          <type>const <ref refid="classtubex_1_1_tube" kindref="compound">Tube</ref> &amp;</type>
          <declname>x</declname>
        </param>
        <briefdescription>
<para>Returns true if this tube is a subset of the interior of <formula id="77">$[x](\cdot)$</formula>. </para>        </briefdescription>
        <detaileddescription>
<para><simplesect kind="note"><para>The two tubes may not share the same slicing, but must have the same tdomain</para></simplesect>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>x</parametername>
</parameternamelist>
<parameterdescription>
<para>the <ref refid="classtubex_1_1_tube" kindref="compound">Tube</ref> object </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>true in case of interior subset </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/simon/tubex-lib/src/core/dynamics/tube/tubex_Tube.h" line="633" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classtubex_1_1_tube_1ae703e7dcf068ea3108c61f41629c6fbf" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool tubex::Tube::is_strict_interior_subset</definition>
        <argsstring>(const Tube &amp;x) const</argsstring>
        <name>is_strict_interior_subset</name>
        <param>
          <type>const <ref refid="classtubex_1_1_tube" kindref="compound">Tube</ref> &amp;</type>
          <declname>x</declname>
        </param>
        <briefdescription>
<para>Returns true if this tube is a subset of the interior of <formula id="77">$[x](\cdot)$</formula>, and not <formula id="77">$[x](\cdot)$</formula> itself. </para>        </briefdescription>
        <detaileddescription>
<para><simplesect kind="note"><para>The two tubes may not share the same slicing, but must have the same tdomain</para></simplesect>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>x</parametername>
</parameternamelist>
<parameterdescription>
<para>the <ref refid="classtubex_1_1_tube" kindref="compound">Tube</ref> object </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>true in case of strict interior subset </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/simon/tubex-lib/src/core/dynamics/tube/tubex_Tube.h" line="645" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classtubex_1_1_tube_1a79914d4ffd1fc2ef7897bf165e5101f0" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool tubex::Tube::is_superset</definition>
        <argsstring>(const Tube &amp;x) const</argsstring>
        <name>is_superset</name>
        <param>
          <type>const <ref refid="classtubex_1_1_tube" kindref="compound">Tube</ref> &amp;</type>
          <declname>x</declname>
        </param>
        <briefdescription>
<para>Returns true if this tube is a superset of <formula id="77">$[x](\cdot)$</formula>. </para>        </briefdescription>
        <detaileddescription>
<para><simplesect kind="note"><para>The two tubes may not share the same slicing, but must have the same tdomain</para></simplesect>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>x</parametername>
</parameternamelist>
<parameterdescription>
<para>the <ref refid="classtubex_1_1_tube" kindref="compound">Tube</ref> object </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>true in case of superset </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/simon/tubex-lib/src/core/dynamics/tube/tubex_Tube.h" line="656" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classtubex_1_1_tube_1a4d192b51c15f101ef970106ce64494f5" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool tubex::Tube::is_strict_superset</definition>
        <argsstring>(const Tube &amp;x) const</argsstring>
        <name>is_strict_superset</name>
        <param>
          <type>const <ref refid="classtubex_1_1_tube" kindref="compound">Tube</ref> &amp;</type>
          <declname>x</declname>
        </param>
        <briefdescription>
<para>Returns true if this tube is a superset of <formula id="77">$[x](\cdot)$</formula>, and not <formula id="77">$[x](\cdot)$</formula> itself. </para>        </briefdescription>
        <detaileddescription>
<para><simplesect kind="note"><para>The two tubes may not share the same slicing, but must have the same tdomain</para></simplesect>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>x</parametername>
</parameternamelist>
<parameterdescription>
<para>the <ref refid="classtubex_1_1_tube" kindref="compound">Tube</ref> object </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>true in case of strict superset </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/simon/tubex-lib/src/core/dynamics/tube/tubex_Tube.h" line="668" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classtubex_1_1_tube_1a2f1a51db56336eb0ef65d4ab1270f88a" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool tubex::Tube::is_empty</definition>
        <argsstring>() const</argsstring>
        <name>is_empty</name>
        <briefdescription>
<para>Returns true if this tube is empty. </para>        </briefdescription>
        <detaileddescription>
<para><simplesect kind="note"><para>If <formula id="274">$[x](t)=\varnothing$</formula> for some <formula id="140">$t$</formula>, then the tube <formula id="77">$[x](\cdot)$</formula> is considered empty</para></simplesect>
<simplesect kind="return"><para>true in case of emptiness </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/simon/tubex-lib/src/core/dynamics/tube/tubex_Tube.h" line="678" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classtubex_1_1_tube_1a06cccd35da11ee89840ccd9c1f859ce8" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>const ibex::BoolInterval</type>
        <definition>const ibex::BoolInterval tubex::Tube::contains</definition>
        <argsstring>(const Trajectory &amp;x) const</argsstring>
        <name>contains</name>
        <param>
          <type>const <ref refid="classtubex_1_1_trajectory" kindref="compound">Trajectory</ref> &amp;</type>
          <declname>x</declname>
        </param>
        <briefdescription>
<para>Returns true if this tube contains the trajectory <formula id="22">$x(\cdot)$</formula>. </para>        </briefdescription>
        <detaileddescription>
<para><anchor id="classtubex_1_1_tube_1DOC__TUBE_CONTAINS"/> <simplesect kind="note"><para>Due to the reliable numerical representation of a trajectory, some wrapping effect may appear for its evaluations (either if it is defined by a map of values or an analytic function). Hence, this &quot;contains&quot; test may not be able to conclude, if the thin envelope of <formula id="22">$x(\cdot)$</formula> overlaps a boundary of the tube.</para></simplesect>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>x</parametername>
</parameternamelist>
<parameterdescription>
<para>the trajectory that might be contained by this tube </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>BoolInterval::YES (or BoolInterval::NO) if this tube contains <formula id="22">$x(\cdot)$</formula> (or does not contain) and <ref refid="namespacetubex_1a372066c8a5956cf6967b21df405dca6ca2bdc01416a885dbb723dc23f956b78f2" kindref="member">BoolInterval::MAYBE</ref> in case of ambiguity </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/simon/tubex-lib/src/core/dynamics/tube/tubex_Tube.h" line="693" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classtubex_1_1_tube_1a65eb032f4186044e3dd46336ace13629" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool tubex::Tube::overlaps</definition>
        <argsstring>(const Tube &amp;x, float ratio=1.) const</argsstring>
        <name>overlaps</name>
        <param>
          <type>const <ref refid="classtubex_1_1_tube" kindref="compound">Tube</ref> &amp;</type>
          <declname>x</declname>
        </param>
        <param>
          <type>float</type>
          <declname>ratio</declname>
          <defval>1.</defval>
        </param>
        <briefdescription>
<para>Returns true if this tube overlaps the tube <formula id="77">$[x](\cdot)$</formula>. </para>        </briefdescription>
        <detaileddescription>
<para><anchor id="classtubex_1_1_tube_1DOC__TUBE_OVERLAPS"/> <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>x</parametername>
</parameternamelist>
<parameterdescription>
<para>the other tube </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>ratio</parametername>
</parameternamelist>
<parameterdescription>
<para>an optional overlapping ratio between 0 and 1 (1 by default). For instance, if ratio=0.3 and there is an overlapping of at least 30%, then the function returns true </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>true in case of overlapping with respect to the defined ratio </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/simon/tubex-lib/src/core/dynamics/tube/tubex_Tube.h" line="705" column="1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="user-defined">
      <header>Setting values</header>
      <memberdef kind="function" id="classtubex_1_1_tube_1aa90ac102791a0c2a9934ccae3f4185a1" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void tubex::Tube::set</definition>
        <argsstring>(const ibex::Interval &amp;y)</argsstring>
        <name>set</name>
        <param>
          <type>const ibex::Interval &amp;</type>
          <declname>y</declname>
        </param>
        <briefdescription>
<para>Sets a constant interval value for this tube: <formula id="275">$\forall t, [x](t)=[y]$</formula>. </para>        </briefdescription>
        <detaileddescription>
<para><simplesect kind="note"><para>The sampling of this tube is preserved</para></simplesect>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>y</parametername>
</parameternamelist>
<parameterdescription>
<para>Interval value of the slices </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/simon/tubex-lib/src/core/dynamics/tube/tubex_Tube.h" line="718" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classtubex_1_1_tube_1a1e0d0a5a1722bc1e68ef152e7de77113" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void tubex::Tube::set</definition>
        <argsstring>(const ibex::Interval &amp;y, int slice_id)</argsstring>
        <name>set</name>
        <param>
          <type>const ibex::Interval &amp;</type>
          <declname>y</declname>
        </param>
        <param>
          <type>int</type>
          <declname>slice_id</declname>
        </param>
        <briefdescription>
<para>Sets the interval value of the ith slice of this tube. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>y</parametername>
</parameternamelist>
<parameterdescription>
<para>Interval value of the ith slice </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>slice_id</parametername>
</parameternamelist>
<parameterdescription>
<para>index of the ith <ref refid="classtubex_1_1_slice" kindref="compound">Slice</ref> </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/simon/tubex-lib/src/core/dynamics/tube/tubex_Tube.h" line="726" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classtubex_1_1_tube_1ac3c1f8930f62f0da9d396fcf9ee09e29" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void tubex::Tube::set</definition>
        <argsstring>(const ibex::Interval &amp;y, double t)</argsstring>
        <name>set</name>
        <param>
          <type>const ibex::Interval &amp;</type>
          <declname>y</declname>
        </param>
        <param>
          <type>double</type>
          <declname>t</declname>
        </param>
        <briefdescription>
<para>Sets the interval value of this tube at <formula id="140">$t$</formula>: <formula id="141">$[x](t)=[y]$</formula>. </para>        </briefdescription>
        <detaileddescription>
<para><simplesect kind="note"><para>It may create a gate (and so one more slice) if the tube is not already sampled at <formula id="140">$t$</formula>. Otherwise, it will update the value of the already existing gate.</para></simplesect>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>y</parametername>
</parameternamelist>
<parameterdescription>
<para>Interval value of the gate </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>t</parametername>
</parameternamelist>
<parameterdescription>
<para>the temporal key (double, must belong to the <ref refid="classtubex_1_1_tube" kindref="compound">Tube</ref>&apos;s tdomain) </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/simon/tubex-lib/src/core/dynamics/tube/tubex_Tube.h" line="738" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classtubex_1_1_tube_1afd55b2b3d8ea432b4335e9e8bcf45d4c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void tubex::Tube::set</definition>
        <argsstring>(const ibex::Interval &amp;y, const ibex::Interval &amp;t)</argsstring>
        <name>set</name>
        <param>
          <type>const ibex::Interval &amp;</type>
          <declname>y</declname>
        </param>
        <param>
          <type>const ibex::Interval &amp;</type>
          <declname>t</declname>
        </param>
        <briefdescription>
<para>Sets the interval value of this tube over <formula id="174">$[t]$</formula>: <formula id="276">$\forall t\in[t], [x](t)=[y]$</formula>. </para>        </briefdescription>
        <detaileddescription>
<para><anchor id="classtubex_1_1_tube_1DOC__TUBE_SET_INTERVAL_INTERVAL"/> <simplesect kind="note"><para>It may create two gates (and so further slices) if the tube is not already sampled at <formula id="200">$t^-$</formula> and <formula id="201">$t^+$</formula>. This is done to ensure that <formula id="276">$\forall t\in[t], [x](t)=[y]$</formula>.</para></simplesect>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>y</parametername>
</parameternamelist>
<parameterdescription>
<para>Interval value to be set </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>t</parametername>
</parameternamelist>
<parameterdescription>
<para>the subtdomain (Interval, must be a subset of the <ref refid="classtubex_1_1_tube" kindref="compound">Tube</ref>&apos;s tdomain) </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/simon/tubex-lib/src/core/dynamics/tube/tubex_Tube.h" line="751" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classtubex_1_1_tube_1a8f8b3b2ac5ee4f5db9e53f0707290abf" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void tubex::Tube::set_empty</definition>
        <argsstring>()</argsstring>
        <name>set_empty</name>
        <briefdescription>
<para>Sets this tube to the empty set. </para>        </briefdescription>
        <detaileddescription>
<para><simplesect kind="note"><para>By convention, all slices will be set to the empty set </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/simon/tubex-lib/src/core/dynamics/tube/tubex_Tube.h" line="758" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classtubex_1_1_tube_1a460ed0d2236efadf89433cc8e8ba65ca" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>const <ref refid="classtubex_1_1_tube" kindref="compound">Tube</ref> &amp;</type>
        <definition>const Tube&amp; tubex::Tube::inflate</definition>
        <argsstring>(double rad)</argsstring>
        <name>inflate</name>
        <param>
          <type>double</type>
          <declname>rad</declname>
        </param>
        <briefdescription>
<para>Inflates this tube by adding <formula id="229">$[-rad,+rad]$</formula> to all its codomain components. </para>        </briefdescription>
        <detaileddescription>
<para><simplesect kind="note"><para>All slices and gates will be inflated</para></simplesect>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>rad</parametername>
</parameternamelist>
<parameterdescription>
<para>half of the inflation </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>*this </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/simon/tubex-lib/src/core/dynamics/tube/tubex_Tube.h" line="768" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classtubex_1_1_tube_1a6bda3d3184cdcd3d485280230119baa4" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>const <ref refid="classtubex_1_1_tube" kindref="compound">Tube</ref> &amp;</type>
        <definition>const Tube&amp; tubex::Tube::inflate</definition>
        <argsstring>(const Trajectory &amp;rad)</argsstring>
        <name>inflate</name>
        <param>
          <type>const <ref refid="classtubex_1_1_trajectory" kindref="compound">Trajectory</ref> &amp;</type>
          <declname>rad</declname>
        </param>
        <briefdescription>
<para>Inflates this tube by adding non-constant uncertainties defined in a trajectory. </para>        </briefdescription>
        <detaileddescription>
<para><simplesect kind="note"><para>From the trajectory <formula id="277">$a(\cdot)$</formula>, the function will inflate this tube such that <formula id="278">$\forall t, [x](t):=[x](t)+[-a(t),+a(t)]$</formula> </para></simplesect>
<simplesect kind="note"><para>All slices and gates will be inflated</para></simplesect>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>rad</parametername>
</parameternamelist>
<parameterdescription>
<para>the <ref refid="classtubex_1_1_trajectory" kindref="compound">Trajectory</ref> object defining the non-constant inflation </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>*this </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/simon/tubex-lib/src/core/dynamics/tube/tubex_Tube.h" line="780" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classtubex_1_1_tube_1a48704a8fff2c68cbc5586d3e26a3b15d" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void tubex::Tube::shift_tdomain</definition>
        <argsstring>(double a)</argsstring>
        <name>shift_tdomain</name>
        <param>
          <type>double</type>
          <declname>a</declname>
        </param>
        <briefdescription>
<para>Shifts the tdomain <formula id="175">$[t_0,t_f]$</formula> of <formula id="77">$[x](\cdot)$</formula>. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>the offset value so that <formula id="279">$[t_0,t_f]:=[t_0+a,t_f+a]$</formula> </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/simon/tubex-lib/src/core/dynamics/tube/tubex_Tube.h" line="787" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classtubex_1_1_tube_1a39a4b25586279ea119126ecda1c64794" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void tubex::Tube::remove_gate</definition>
        <argsstring>(double t)</argsstring>
        <name>remove_gate</name>
        <param>
          <type>double</type>
          <declname>t</declname>
        </param>
        <briefdescription>
<para>Removes the gate at <formula id="140">$t$</formula> and merges the two related slices. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>t</parametername>
</parameternamelist>
<parameterdescription>
<para>time input where the gate to remove is </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/simon/tubex-lib/src/core/dynamics/tube/tubex_Tube.h" line="794" column="1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="user-defined">
      <header>Bisection</header>
      <memberdef kind="function" id="classtubex_1_1_tube_1a8d16505bd2fd1bff9c545327f427cdc9" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>const std::pair&lt; <ref refid="classtubex_1_1_tube" kindref="compound">Tube</ref>, <ref refid="classtubex_1_1_tube" kindref="compound">Tube</ref> &gt;</type>
        <definition>const std::pair&lt;Tube,Tube&gt; tubex::Tube::bisect</definition>
        <argsstring>(double t, float ratio=0.49) const</argsstring>
        <name>bisect</name>
        <param>
          <type>double</type>
          <declname>t</declname>
        </param>
        <param>
          <type>float</type>
          <declname>ratio</declname>
          <defval>0.49</defval>
        </param>
        <briefdescription>
<para>Bisects this tube. </para>        </briefdescription>
        <detaileddescription>
<para><anchor id="classtubex_1_1_tube_1DOC__TUBE_BISECT"/> <simplesect kind="note"><para>The tube is bisected along the codomain and according to a defined ratio </para></simplesect>
<simplesect kind="note"><para>The bisection is performed on the interval value of the gate <formula id="261">$[x](t)$</formula> </para></simplesect>
<simplesect kind="note"><para>If the tube is not already sampled at <formula id="140">$t$</formula>, then a sampling is performed</para></simplesect>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>t</parametername>
</parameternamelist>
<parameterdescription>
<para>the temporal key (double, must belong to the <ref refid="classtubex_1_1_tube" kindref="compound">Tube</ref>&apos;s tdomain) </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>ratio</parametername>
</parameternamelist>
<parameterdescription>
<para>the bisection ratio (default value: 0.55) </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>a pair of two <ref refid="classtubex_1_1_tube" kindref="compound">Tube</ref> objects resulting from the bisection </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/simon/tubex-lib/src/core/dynamics/tube/tubex_Tube.h" line="812" column="1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="user-defined">
      <header>Assignments operators</header>
      <memberdef kind="function" id="classtubex_1_1_tube_1a1c2f5a318a7b4b59935f907545bed48b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>const <ref refid="classtubex_1_1_tube" kindref="compound">Tube</ref> &amp;</type>
        <definition>const Tube&amp; tubex::Tube::operator+=</definition>
        <argsstring>(const ibex::Interval &amp;x)</argsstring>
        <name>operator+=</name>
        <param>
          <type>const ibex::Interval &amp;</type>
          <declname>x</declname>
        </param>
        <briefdescription>
<para>Operates +=. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>x</parametername>
</parameternamelist>
<parameterdescription>
<para>Interval </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>(*this)+=x </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/simon/tubex-lib/src/core/dynamics/tube/tubex_Tube.h" line="824" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classtubex_1_1_tube_1a9e4f61f0f587e9cea87a0eb9e531d804" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>const <ref refid="classtubex_1_1_tube" kindref="compound">Tube</ref> &amp;</type>
        <definition>const Tube&amp; tubex::Tube::operator+=</definition>
        <argsstring>(const Trajectory &amp;x)</argsstring>
        <name>operator+=</name>
        <param>
          <type>const <ref refid="classtubex_1_1_trajectory" kindref="compound">Trajectory</ref> &amp;</type>
          <declname>x</declname>
        </param>
        <briefdescription>
<para>Operates +=. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>x</parametername>
</parameternamelist>
<parameterdescription>
<para><ref refid="classtubex_1_1_trajectory" kindref="compound">Trajectory</ref> </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>(*this)+=x </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/simon/tubex-lib/src/core/dynamics/tube/tubex_Tube.h" line="832" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classtubex_1_1_tube_1aae7b9eed169971bb74094d24f55a212d" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>const <ref refid="classtubex_1_1_tube" kindref="compound">Tube</ref> &amp;</type>
        <definition>const Tube&amp; tubex::Tube::operator+=</definition>
        <argsstring>(const Tube &amp;x)</argsstring>
        <name>operator+=</name>
        <param>
          <type>const <ref refid="classtubex_1_1_tube" kindref="compound">Tube</ref> &amp;</type>
          <declname>x</declname>
        </param>
        <briefdescription>
<para>Operates +=. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>x</parametername>
</parameternamelist>
<parameterdescription>
<para><ref refid="classtubex_1_1_tube" kindref="compound">Tube</ref> </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>(*this)+=x </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/simon/tubex-lib/src/core/dynamics/tube/tubex_Tube.h" line="840" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classtubex_1_1_tube_1a42a0133b9ad4c07e9b40e72f807cc850" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>const <ref refid="classtubex_1_1_tube" kindref="compound">Tube</ref> &amp;</type>
        <definition>const Tube&amp; tubex::Tube::operator-=</definition>
        <argsstring>(const ibex::Interval &amp;x)</argsstring>
        <name>operator-=</name>
        <param>
          <type>const ibex::Interval &amp;</type>
          <declname>x</declname>
        </param>
        <briefdescription>
<para>Operates -=. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>x</parametername>
</parameternamelist>
<parameterdescription>
<para>Interval </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>(*this)-=x </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/simon/tubex-lib/src/core/dynamics/tube/tubex_Tube.h" line="848" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classtubex_1_1_tube_1a624d0efd45b7ca92bdb383dc1d546109" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>const <ref refid="classtubex_1_1_tube" kindref="compound">Tube</ref> &amp;</type>
        <definition>const Tube&amp; tubex::Tube::operator-=</definition>
        <argsstring>(const Trajectory &amp;x)</argsstring>
        <name>operator-=</name>
        <param>
          <type>const <ref refid="classtubex_1_1_trajectory" kindref="compound">Trajectory</ref> &amp;</type>
          <declname>x</declname>
        </param>
        <briefdescription>
<para>Operates -=. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>x</parametername>
</parameternamelist>
<parameterdescription>
<para><ref refid="classtubex_1_1_trajectory" kindref="compound">Trajectory</ref> </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>(*this)-=x </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/simon/tubex-lib/src/core/dynamics/tube/tubex_Tube.h" line="856" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classtubex_1_1_tube_1ad1dd8d133ab63dc0a5eb8795857a7899" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>const <ref refid="classtubex_1_1_tube" kindref="compound">Tube</ref> &amp;</type>
        <definition>const Tube&amp; tubex::Tube::operator-=</definition>
        <argsstring>(const Tube &amp;x)</argsstring>
        <name>operator-=</name>
        <param>
          <type>const <ref refid="classtubex_1_1_tube" kindref="compound">Tube</ref> &amp;</type>
          <declname>x</declname>
        </param>
        <briefdescription>
<para>Operates -=. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>x</parametername>
</parameternamelist>
<parameterdescription>
<para><ref refid="classtubex_1_1_tube" kindref="compound">Tube</ref> </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>(*this)-=x </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/simon/tubex-lib/src/core/dynamics/tube/tubex_Tube.h" line="864" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classtubex_1_1_tube_1a1a781338288203674805cd6cf3aa4ef6" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>const <ref refid="classtubex_1_1_tube" kindref="compound">Tube</ref> &amp;</type>
        <definition>const Tube&amp; tubex::Tube::operator*=</definition>
        <argsstring>(const ibex::Interval &amp;x)</argsstring>
        <name>operator*=</name>
        <param>
          <type>const ibex::Interval &amp;</type>
          <declname>x</declname>
        </param>
        <briefdescription>
<para>Operates *=. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>x</parametername>
</parameternamelist>
<parameterdescription>
<para>Interval </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>(<emphasis>this)</emphasis>=x </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/simon/tubex-lib/src/core/dynamics/tube/tubex_Tube.h" line="872" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classtubex_1_1_tube_1a7b17b6357a2b80b309194fee2d45fbb8" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>const <ref refid="classtubex_1_1_tube" kindref="compound">Tube</ref> &amp;</type>
        <definition>const Tube&amp; tubex::Tube::operator*=</definition>
        <argsstring>(const Trajectory &amp;x)</argsstring>
        <name>operator*=</name>
        <param>
          <type>const <ref refid="classtubex_1_1_trajectory" kindref="compound">Trajectory</ref> &amp;</type>
          <declname>x</declname>
        </param>
        <briefdescription>
<para>Operates *=. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>x</parametername>
</parameternamelist>
<parameterdescription>
<para><ref refid="classtubex_1_1_trajectory" kindref="compound">Trajectory</ref> </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>(<emphasis>this)</emphasis>=x </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/simon/tubex-lib/src/core/dynamics/tube/tubex_Tube.h" line="880" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classtubex_1_1_tube_1a65d93d892059de118773224e47e89ccd" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>const <ref refid="classtubex_1_1_tube" kindref="compound">Tube</ref> &amp;</type>
        <definition>const Tube&amp; tubex::Tube::operator*=</definition>
        <argsstring>(const Tube &amp;x)</argsstring>
        <name>operator*=</name>
        <param>
          <type>const <ref refid="classtubex_1_1_tube" kindref="compound">Tube</ref> &amp;</type>
          <declname>x</declname>
        </param>
        <briefdescription>
<para>Operates *=. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>x</parametername>
</parameternamelist>
<parameterdescription>
<para><ref refid="classtubex_1_1_tube" kindref="compound">Tube</ref> </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>(<emphasis>this)</emphasis>=x </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/simon/tubex-lib/src/core/dynamics/tube/tubex_Tube.h" line="888" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classtubex_1_1_tube_1a68b0cd25a4de8b868b355552f7e28fa9" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>const <ref refid="classtubex_1_1_tube" kindref="compound">Tube</ref> &amp;</type>
        <definition>const Tube&amp; tubex::Tube::operator/=</definition>
        <argsstring>(const ibex::Interval &amp;x)</argsstring>
        <name>operator/=</name>
        <param>
          <type>const ibex::Interval &amp;</type>
          <declname>x</declname>
        </param>
        <briefdescription>
<para>Operates /=. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>x</parametername>
</parameternamelist>
<parameterdescription>
<para>Interval </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>(*this)/=x </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/simon/tubex-lib/src/core/dynamics/tube/tubex_Tube.h" line="896" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classtubex_1_1_tube_1af3ed062e8f1184d7f7a0be587315d8f0" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>const <ref refid="classtubex_1_1_tube" kindref="compound">Tube</ref> &amp;</type>
        <definition>const Tube&amp; tubex::Tube::operator/=</definition>
        <argsstring>(const Trajectory &amp;x)</argsstring>
        <name>operator/=</name>
        <param>
          <type>const <ref refid="classtubex_1_1_trajectory" kindref="compound">Trajectory</ref> &amp;</type>
          <declname>x</declname>
        </param>
        <briefdescription>
<para>Operates /=. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>x</parametername>
</parameternamelist>
<parameterdescription>
<para><ref refid="classtubex_1_1_trajectory" kindref="compound">Trajectory</ref> </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>(*this)/=x </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/simon/tubex-lib/src/core/dynamics/tube/tubex_Tube.h" line="904" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classtubex_1_1_tube_1ae84fd06eeaf3573500662bb3ada1024c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>const <ref refid="classtubex_1_1_tube" kindref="compound">Tube</ref> &amp;</type>
        <definition>const Tube&amp; tubex::Tube::operator/=</definition>
        <argsstring>(const Tube &amp;x)</argsstring>
        <name>operator/=</name>
        <param>
          <type>const <ref refid="classtubex_1_1_tube" kindref="compound">Tube</ref> &amp;</type>
          <declname>x</declname>
        </param>
        <briefdescription>
<para>Operates /=. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>x</parametername>
</parameternamelist>
<parameterdescription>
<para><ref refid="classtubex_1_1_tube" kindref="compound">Tube</ref> </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>(*this)/=x </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/simon/tubex-lib/src/core/dynamics/tube/tubex_Tube.h" line="912" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classtubex_1_1_tube_1ab4f96e40e1ccf1616e570730bd2f12c0" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>const <ref refid="classtubex_1_1_tube" kindref="compound">Tube</ref> &amp;</type>
        <definition>const Tube&amp; tubex::Tube::operator|=</definition>
        <argsstring>(const ibex::Interval &amp;x)</argsstring>
        <name>operator|=</name>
        <param>
          <type>const ibex::Interval &amp;</type>
          <declname>x</declname>
        </param>
        <briefdescription>
<para>Operates |=. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>x</parametername>
</parameternamelist>
<parameterdescription>
<para>Interval </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>(*this)|=x </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/simon/tubex-lib/src/core/dynamics/tube/tubex_Tube.h" line="920" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classtubex_1_1_tube_1ad80666b632c2d81e3c5455c34c503d10" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>const <ref refid="classtubex_1_1_tube" kindref="compound">Tube</ref> &amp;</type>
        <definition>const Tube&amp; tubex::Tube::operator|=</definition>
        <argsstring>(const Trajectory &amp;x)</argsstring>
        <name>operator|=</name>
        <param>
          <type>const <ref refid="classtubex_1_1_trajectory" kindref="compound">Trajectory</ref> &amp;</type>
          <declname>x</declname>
        </param>
        <briefdescription>
<para>Operates |=. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>x</parametername>
</parameternamelist>
<parameterdescription>
<para><ref refid="classtubex_1_1_trajectory" kindref="compound">Trajectory</ref> </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>(*this)|=x </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/simon/tubex-lib/src/core/dynamics/tube/tubex_Tube.h" line="928" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classtubex_1_1_tube_1a4b38a2352e9a5dd1ed8662612a9795e6" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>const <ref refid="classtubex_1_1_tube" kindref="compound">Tube</ref> &amp;</type>
        <definition>const Tube&amp; tubex::Tube::operator|=</definition>
        <argsstring>(const Tube &amp;x)</argsstring>
        <name>operator|=</name>
        <param>
          <type>const <ref refid="classtubex_1_1_tube" kindref="compound">Tube</ref> &amp;</type>
          <declname>x</declname>
        </param>
        <briefdescription>
<para>Operates |=. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>x</parametername>
</parameternamelist>
<parameterdescription>
<para><ref refid="classtubex_1_1_tube" kindref="compound">Tube</ref> </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>(*this)|=x </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/simon/tubex-lib/src/core/dynamics/tube/tubex_Tube.h" line="936" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classtubex_1_1_tube_1abd9f0a2f67b6078c34ba7d8d2123c169" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>const <ref refid="classtubex_1_1_tube" kindref="compound">Tube</ref> &amp;</type>
        <definition>const Tube&amp; tubex::Tube::operator&amp;=</definition>
        <argsstring>(const ibex::Interval &amp;x)</argsstring>
        <name>operator &amp;=</name>
        <param>
          <type>const ibex::Interval &amp;</type>
          <declname>x</declname>
        </param>
        <briefdescription>
<para>Operates &amp;=. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>x</parametername>
</parameternamelist>
<parameterdescription>
<para>Interval </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>(*this)&amp;=x </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/simon/tubex-lib/src/core/dynamics/tube/tubex_Tube.h" line="944" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classtubex_1_1_tube_1ab277c93719ee67e9b74c64df37a729b1" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>const <ref refid="classtubex_1_1_tube" kindref="compound">Tube</ref> &amp;</type>
        <definition>const Tube&amp; tubex::Tube::operator&amp;=</definition>
        <argsstring>(const Trajectory &amp;x)</argsstring>
        <name>operator &amp;=</name>
        <param>
          <type>const <ref refid="classtubex_1_1_trajectory" kindref="compound">Trajectory</ref> &amp;</type>
          <declname>x</declname>
        </param>
        <briefdescription>
<para>Operates &amp;=. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>x</parametername>
</parameternamelist>
<parameterdescription>
<para><ref refid="classtubex_1_1_trajectory" kindref="compound">Trajectory</ref> </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>(*this)&amp;=x </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/simon/tubex-lib/src/core/dynamics/tube/tubex_Tube.h" line="952" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classtubex_1_1_tube_1a90cbfe5ccf7eff3dc5b1ba8d59c8fbaf" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>const <ref refid="classtubex_1_1_tube" kindref="compound">Tube</ref> &amp;</type>
        <definition>const Tube&amp; tubex::Tube::operator&amp;=</definition>
        <argsstring>(const Tube &amp;x)</argsstring>
        <name>operator &amp;=</name>
        <param>
          <type>const <ref refid="classtubex_1_1_tube" kindref="compound">Tube</ref> &amp;</type>
          <declname>x</declname>
        </param>
        <briefdescription>
<para>Operates &amp;=. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>x</parametername>
</parameternamelist>
<parameterdescription>
<para><ref refid="classtubex_1_1_tube" kindref="compound">Tube</ref> </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>(*this)&amp;=x </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/simon/tubex-lib/src/core/dynamics/tube/tubex_Tube.h" line="960" column="1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="user-defined">
      <header>String</header>
      <memberdef kind="friend" id="classtubex_1_1_tube_1ae9b1a489fad33a7319c3ce6d6721b707" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>friend std::ostream &amp;</type>
        <definition>std::ostream&amp; operator&lt;&lt;</definition>
        <argsstring>(std::ostream &amp;str, const Tube &amp;x)</argsstring>
        <name>operator&lt;&lt;</name>
        <param>
          <type>std::ostream &amp;</type>
          <declname>str</declname>
        </param>
        <param>
          <type>const <ref refid="classtubex_1_1_tube" kindref="compound">Tube</ref> &amp;</type>
          <declname>x</declname>
        </param>
        <briefdescription>
<para>Displays a synthesis of this tube. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>str</parametername>
</parameternamelist>
<parameterdescription>
<para>ostream </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>x</parametername>
</parameternamelist>
<parameterdescription>
<para>tube to be displayed </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>ostream </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/simon/tubex-lib/src/core/dynamics/tube/tubex_Tube.h" line="982" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classtubex_1_1_tube_1a0ad5db5eb8ac2d8d64149a7f422349f6" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="virtual">
        <type>const std::string</type>
        <definition>const std::string tubex::Tube::class_name</definition>
        <argsstring>() const</argsstring>
        <name>class_name</name>
        <reimplements refid="classtubex_1_1_dynamical_item_1a95edd09d8c6dcbd778b7b623209c46be">class_name</reimplements>
        <briefdescription>
<para>Returns the name of this class. </para>        </briefdescription>
        <detaileddescription>
<para><simplesect kind="note"><para>Only used for some generic display method</para></simplesect>
<simplesect kind="return"><para>the predefined name </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/simon/tubex-lib/src/core/dynamics/tube/tubex_Tube.h" line="973" column="1" bodyfile="/home/simon/tubex-lib/src/core/dynamics/tube/tubex_Tube.h" bodystart="973" bodyend="973"/>
      </memberdef>
      <memberdef kind="function" id="classtubex_1_1_tube_1a3b627f4fc18a4236e294e8897cd1629f" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void tubex::Tube::enable_synthesis</definition>
        <argsstring>(bool enable=true) const</argsstring>
        <name>enable_synthesis</name>
        <param>
          <type>bool</type>
          <declname>enable</declname>
          <defval>true</defval>
        </param>
        <briefdescription>
<para>Enables the computation of a synthesis tree. </para>        </briefdescription>
        <detaileddescription>
<para><simplesect kind="note"><para>The synthesis tree speeds up computations such as integrals or evaluations</para></simplesect>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>enable</parametername>
</parameternamelist>
<parameterdescription>
<para>boolean </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/simon/tubex-lib/src/core/dynamics/tube/tubex_Tube.h" line="993" column="1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="user-defined">
      <header>Integration</header>
      <memberdef kind="function" id="classtubex_1_1_tube_1add1f58e49b074534b2688c72da564e62" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>const ibex::Interval</type>
        <definition>const ibex::Interval tubex::Tube::integral</definition>
        <argsstring>(double t) const</argsstring>
        <name>integral</name>
        <param>
          <type>double</type>
          <declname>t</declname>
        </param>
        <briefdescription>
<para>Computes the interval integral <formula id="280">$\int_0^t[x](\tau)d\tau$</formula>. </para>        </briefdescription>
        <detaileddescription>
<para><anchor id="classtubex_1_1_tube_1DOC__TUBE_INTEGRAL_DOUBLE"/> <simplesect kind="note"><para>From the monotonicity of the integral operator, <formula id="281">$\int_0^t[x](\tau)d\tau=[\int_0^t x^-(\tau)d\tau,\int_0^t x^+(\tau)d\tau]$</formula></para></simplesect>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>t</parametername>
</parameternamelist>
<parameterdescription>
<para>the temporal key (double, must belong to the <ref refid="classtubex_1_1_tube" kindref="compound">Tube</ref>&apos;s tdomain) </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>the set of feasible integral values </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/simon/tubex-lib/src/core/dynamics/tube/tubex_Tube.h" line="1009" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classtubex_1_1_tube_1ae9094d5b6b3960982fc14451669d537a" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>const ibex::Interval</type>
        <definition>const ibex::Interval tubex::Tube::integral</definition>
        <argsstring>(const ibex::Interval &amp;t) const</argsstring>
        <name>integral</name>
        <param>
          <type>const ibex::Interval &amp;</type>
          <declname>t</declname>
        </param>
        <briefdescription>
<para>Computes the interval integral <formula id="282">$\int_0^{[t]}[x](\tau)d\tau$</formula>. </para>        </briefdescription>
        <detaileddescription>
<para><simplesect kind="note"><para>From the monotonicity of the integral operator, <formula id="283">$\int_0^{[t]}[x](\tau)d\tau=[\int_0^{[t]}x^-(\tau)d\tau,\int_0^{[t]}x^+(\tau)d\tau]$</formula></para></simplesect>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>t</parametername>
</parameternamelist>
<parameterdescription>
<para>the subtdomain (Interval, must be a subset of the <ref refid="classtubex_1_1_tube" kindref="compound">Tube</ref>&apos;s tdomain) </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>the set of feasible integral values </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/simon/tubex-lib/src/core/dynamics/tube/tubex_Tube.h" line="1020" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classtubex_1_1_tube_1aae0985461a567f613977135c92e99533" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>const ibex::Interval</type>
        <definition>const ibex::Interval tubex::Tube::integral</definition>
        <argsstring>(const ibex::Interval &amp;t1, const ibex::Interval &amp;t2) const</argsstring>
        <name>integral</name>
        <param>
          <type>const ibex::Interval &amp;</type>
          <declname>t1</declname>
        </param>
        <param>
          <type>const ibex::Interval &amp;</type>
          <declname>t2</declname>
        </param>
        <briefdescription>
<para>Computes the interval integral <formula id="284">$\int_{[t_1]}^{[t_2]}[x](\tau)d\tau$</formula>. </para>        </briefdescription>
        <detaileddescription>
<para><simplesect kind="note"><para>From the monotonicity of the integral operator, <formula id="285">$\int_{[t_1]}^{[t_2]}[x](\tau)d\tau=[\int_{[t_1]}^{[t_2]}x^-(\tau)d\tau,\int_{[t_1]}^{[t_2]}x^+(\tau)d\tau]$</formula></para></simplesect>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>t1</parametername>
</parameternamelist>
<parameterdescription>
<para>lower bound, subset of the <ref refid="classtubex_1_1_tube" kindref="compound">Tube</ref>&apos;s tdomain </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>t2</parametername>
</parameternamelist>
<parameterdescription>
<para>upper bound, subset of the <ref refid="classtubex_1_1_tube" kindref="compound">Tube</ref>&apos;s tdomain </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>the set of feasible integral values </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/simon/tubex-lib/src/core/dynamics/tube/tubex_Tube.h" line="1032" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classtubex_1_1_tube_1a5f47c14bf9837186f2eb0003b56d1c96" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>const std::pair&lt; ibex::Interval, ibex::Interval &gt;</type>
        <definition>const std::pair&lt;ibex::Interval,ibex::Interval&gt; tubex::Tube::partial_integral</definition>
        <argsstring>(const ibex::Interval &amp;t) const</argsstring>
        <name>partial_integral</name>
        <param>
          <type>const ibex::Interval &amp;</type>
          <declname>t</declname>
        </param>
        <briefdescription>
<para>Computes the partial interval integral <formula id="286">$\int_{0}^{[t]}[x](\tau)d\tau$</formula>. </para>        </briefdescription>
        <detaileddescription>
<para><simplesect kind="note"><para>From the monotonicity of the integral operator, <formula id="287">$\int_{0}^{[t]}[x](\tau)d\tau=[\int_{0}^{[t]}x^-(\tau)d\tau,\int_{0}^{[t]}x^+(\tau)d\tau]$</formula></para></simplesect>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>t</parametername>
</parameternamelist>
<parameterdescription>
<para>interval upper bound, subset of the <ref refid="classtubex_1_1_tube" kindref="compound">Tube</ref>&apos;s tdomain </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>the pair <formula id="288">$\big([i^-],[i^+]\big)$</formula>, where <formula id="289">$[i^-]=\int_{0}^{[t]}x^-(\tau)d\tau$</formula> and <formula id="290">$[i^+]=\int_{0}^{[t]}x^+(\tau)d\tau$</formula> </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/simon/tubex-lib/src/core/dynamics/tube/tubex_Tube.h" line="1045" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classtubex_1_1_tube_1a4ea8ee3b43cdba6ab2c178c54901d00b" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>const std::pair&lt; ibex::Interval, ibex::Interval &gt;</type>
        <definition>const std::pair&lt;ibex::Interval,ibex::Interval&gt; tubex::Tube::partial_integral</definition>
        <argsstring>(const ibex::Interval &amp;t1, const ibex::Interval &amp;t2) const</argsstring>
        <name>partial_integral</name>
        <param>
          <type>const ibex::Interval &amp;</type>
          <declname>t1</declname>
        </param>
        <param>
          <type>const ibex::Interval &amp;</type>
          <declname>t2</declname>
        </param>
        <briefdescription>
<para>Computes the partial interval integral <formula id="284">$\int_{[t_1]}^{[t_2]}[x](\tau)d\tau$</formula>. </para>        </briefdescription>
        <detaileddescription>
<para><simplesect kind="note"><para>From the monotonicity of the integral operator, <formula id="285">$\int_{[t_1]}^{[t_2]}[x](\tau)d\tau=[\int_{[t_1]}^{[t_2]}x^-(\tau)d\tau,\int_{[t_1]}^{[t_2]}x^+(\tau)d\tau]$</formula></para></simplesect>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>t1</parametername>
</parameternamelist>
<parameterdescription>
<para>interval lower bound, subset of the <ref refid="classtubex_1_1_tube" kindref="compound">Tube</ref>&apos;s tdomain </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>t2</parametername>
</parameternamelist>
<parameterdescription>
<para>interval upper bound, subset of the <ref refid="classtubex_1_1_tube" kindref="compound">Tube</ref>&apos;s tdomain </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>the pair <formula id="288">$\big([i^-],[i^+]\big)$</formula>, where <formula id="291">$[i^-]=\int_{[t_1]}^{[t_2]}x^-(\tau)d\tau$</formula> and <formula id="292">$[i^+]=\int_{[t_1]}^{[t_2]}x^+(\tau)d\tau$</formula> </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/simon/tubex-lib/src/core/dynamics/tube/tubex_Tube.h" line="1059" column="1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="user-defined">
      <header>Serialization</header>
      <memberdef kind="function" id="classtubex_1_1_tube_1ab6cb813c5fe3e3e6e1bd0bb0861552bb" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void tubex::Tube::serialize</definition>
        <argsstring>(const std::string &amp;binary_file_name=&quot;x.tube&quot;, int version_number=SERIALIZATION_VERSION) const</argsstring>
        <name>serialize</name>
        <param>
          <type>const std::string &amp;</type>
          <declname>binary_file_name</declname>
          <defval>&quot;x.tube&quot;</defval>
        </param>
        <param>
          <type>int</type>
          <declname>version_number</declname>
          <defval>SERIALIZATION_VERSION</defval>
        </param>
        <briefdescription>
<para>Serializes this tube. </para>        </briefdescription>
        <detaileddescription>
<para><simplesect kind="note"><para>The values and sampling (slices and gates) are serialized</para></simplesect>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>binary_file_name</parametername>
</parameternamelist>
<parameterdescription>
<para>name of the output file (default value: &quot;x.tube&quot;) </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>version_number</parametername>
</parameternamelist>
<parameterdescription>
<para>serialization version (used for tests purposes, default value: last version) </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/simon/tubex-lib/src/core/dynamics/tube/tubex_Tube.h" line="1073" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classtubex_1_1_tube_1a00ab3eefcfc6c60cd909d5c85fd34049" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void tubex::Tube::serialize</definition>
        <argsstring>(const std::string &amp;binary_file_name, const Trajectory &amp;traj, int version_number=SERIALIZATION_VERSION) const</argsstring>
        <name>serialize</name>
        <param>
          <type>const std::string &amp;</type>
          <declname>binary_file_name</declname>
        </param>
        <param>
          <type>const <ref refid="classtubex_1_1_trajectory" kindref="compound">Trajectory</ref> &amp;</type>
          <declname>traj</declname>
        </param>
        <param>
          <type>int</type>
          <declname>version_number</declname>
          <defval>SERIALIZATION_VERSION</defval>
        </param>
        <briefdescription>
<para>Serializes this tube together with a <ref refid="classtubex_1_1_trajectory" kindref="compound">Trajectory</ref> object. </para>        </briefdescription>
        <detaileddescription>
<para><simplesect kind="note"><para>The values and sampling (slices and gates) are serialized </para></simplesect>
<simplesect kind="note"><para>The serialization of a <ref refid="classtubex_1_1_trajectory" kindref="compound">Trajectory</ref> defined from a TFunction object is not supported </para></simplesect>
<simplesect kind="note"><para>The output file will appear in the executable current directory</para></simplesect>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>binary_file_name</parametername>
</parameternamelist>
<parameterdescription>
<para>name of the output file (default value: &quot;x.tube&quot;) </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>traj</parametername>
</parameternamelist>
<parameterdescription>
<para>the <ref refid="classtubex_1_1_trajectory" kindref="compound">Trajectory</ref> object to serialize (for instance, actual but unknown values) </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>version_number</parametername>
</parameternamelist>
<parameterdescription>
<para>serialization version (used for tests purposes, default value: last version) </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/simon/tubex-lib/src/core/dynamics/tube/tubex_Tube.h" line="1086" column="1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="protected-attrib">
      <memberdef kind="variable" id="classtubex_1_1_tube_1a8c3037a4e9d23249429a98015507ff3b" prot="protected" static="no" mutable="no">
        <type><ref refid="classtubex_1_1_slice" kindref="compound">Slice</ref> *</type>
        <definition>Slice* tubex::Tube::m_first_slice</definition>
        <argsstring></argsstring>
        <name>m_first_slice</name>
        <initializer>= NULL</initializer>
        <briefdescription>
<para>pointer to the first <ref refid="classtubex_1_1_slice" kindref="compound">Slice</ref> object of this tube </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/simon/tubex-lib/src/core/dynamics/tube/tubex_Tube.h" line="1162" column="1" bodyfile="/home/simon/tubex-lib/src/core/dynamics/tube/tubex_Tube.h" bodystart="1162" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="classtubex_1_1_tube_1abf341f24f980f38357ccfcc8540d0e2c" prot="protected" static="no" mutable="yes">
        <type>TubeTreeSynthesis *</type>
        <definition>TubeTreeSynthesis* tubex::Tube::m_synthesis_tree</definition>
        <argsstring></argsstring>
        <name>m_synthesis_tree</name>
        <initializer>= NULL</initializer>
        <briefdescription>
<para>pointer to the optional synthesis tree </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/simon/tubex-lib/src/core/dynamics/tube/tubex_Tube.h" line="1163" column="1" bodyfile="/home/simon/tubex-lib/src/core/dynamics/tube/tubex_Tube.h" bodystart="1163" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="classtubex_1_1_tube_1a2cba1623d4aa00fc79db5eb8224797a9" prot="protected" static="no" mutable="yes">
        <type>bool</type>
        <definition>bool tubex::Tube::m_enable_synthesis</definition>
        <argsstring></argsstring>
        <name>m_enable_synthesis</name>
        <initializer>= Tube::s_enable_syntheses</initializer>
        <briefdescription>
<para>enables of the use of a synthesis tree </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/simon/tubex-lib/src/core/dynamics/tube/tubex_Tube.h" line="1164" column="1" bodyfile="/home/simon/tubex-lib/src/core/dynamics/tube/tubex_Tube.h" bodystart="1164" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="classtubex_1_1_tube_1a0d01c095852464d661996d5fd150b685" prot="protected" static="no" mutable="no">
        <type>ibex::Interval</type>
        <definition>ibex::Interval tubex::Tube::m_tdomain</definition>
        <argsstring></argsstring>
        <name>m_tdomain</name>
        <briefdescription>
<para>redundant information for fast evaluations </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/simon/tubex-lib/src/core/dynamics/tube/tubex_Tube.h" line="1165" column="1" bodyfile="/home/simon/tubex-lib/src/core/dynamics/tube/tubex_Tube.h" bodystart="1165" bodyend="-1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="friend">
      <memberdef kind="friend" id="classtubex_1_1_tube_1accbaf1cf36f790b5ad2284c44fa0f2a6" prot="protected" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>friend class</type>
        <definition>friend class TubeVector</definition>
        <argsstring></argsstring>
        <name>TubeVector</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/simon/tubex-lib/src/core/dynamics/tube/tubex_Tube.h" line="1169" column="1" bodyfile="/home/simon/tubex-lib/src/core/dynamics/tube/tubex_Tube.h" bodystart="1169" bodyend="-1"/>
      </memberdef>
      <memberdef kind="friend" id="classtubex_1_1_tube_1af30b7c49c887a79f0d480f33efe4b0aa" prot="protected" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>friend class</type>
        <definition>friend class CtcEval</definition>
        <argsstring></argsstring>
        <name>CtcEval</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/simon/tubex-lib/src/core/dynamics/tube/tubex_Tube.h" line="1170" column="1" bodyfile="/home/simon/tubex-lib/src/core/dynamics/tube/tubex_Tube.h" bodystart="1170" bodyend="-1"/>
      </memberdef>
      <memberdef kind="friend" id="classtubex_1_1_tube_1aa65bdf2e686e848d31ab4fd0cca0f35a" prot="protected" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>friend void</type>
        <definition>void deserialize_Tube</definition>
        <argsstring>(std::ifstream &amp;bin_file, Tube *&amp;tube)</argsstring>
        <name>deserialize_Tube</name>
        <param>
          <type>std::ifstream &amp;</type>
          <declname>bin_file</declname>
        </param>
        <param>
          <type><ref refid="classtubex_1_1_tube" kindref="compound">Tube</ref> *&amp;</type>
          <declname>tube</declname>
        </param>
        <briefdescription>
<para>Creates a <ref refid="classtubex_1_1_tube" kindref="compound">Tube</ref> object from a binary file. </para>        </briefdescription>
        <detaileddescription>
<para>The binary file has to be written by the <ref refid="namespacetubex_1a465264cfa6cbc82a8bed172850733a71" kindref="member">serialize_Tube()</ref> function.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>bin_file</parametername>
</parameternamelist>
<parameterdescription>
<para>binary file (ifstream object) </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>tube</parametername>
</parameternamelist>
<parameterdescription>
<para><ref refid="classtubex_1_1_tube" kindref="compound">Tube</ref> object to be deserialized </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/simon/tubex-lib/src/core/dynamics/tube/tubex_Tube.h" line="1167" column="1"/>
      </memberdef>
      <memberdef kind="friend" id="classtubex_1_1_tube_1afe5e200d7126a96527f49e98577a0116" prot="protected" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>friend void</type>
        <definition>void deserialize_TubeVector</definition>
        <argsstring>(std::ifstream &amp;bin_file, TubeVector *&amp;tube)</argsstring>
        <name>deserialize_TubeVector</name>
        <param>
          <type>std::ifstream &amp;</type>
          <declname>bin_file</declname>
        </param>
        <param>
          <type><ref refid="classtubex_1_1_tube_vector" kindref="compound">TubeVector</ref> *&amp;</type>
          <declname>tube</declname>
        </param>
        <briefdescription>
<para>Creates a <ref refid="classtubex_1_1_tube_vector" kindref="compound">TubeVector</ref> object from a binary file. </para>        </briefdescription>
        <detaileddescription>
<para>The binary file has to be written by the <ref refid="namespacetubex_1a72fe3aee187745afa93ee19328c3611b" kindref="member">serialize_TubeVector()</ref> function.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>bin_file</parametername>
</parameternamelist>
<parameterdescription>
<para>binary file (ifstream object) </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>tube</parametername>
</parameternamelist>
<parameterdescription>
<para><ref refid="classtubex_1_1_tube_vector" kindref="compound">TubeVector</ref> object to be deserialized </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/simon/tubex-lib/src/core/dynamics/tube/tubex_Tube.h" line="1168" column="1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="protected-static-attrib">
      <memberdef kind="variable" id="classtubex_1_1_tube_1a15f696984ecc1442b6aec9ced82b1da8" prot="protected" static="yes" mutable="no">
        <type>bool</type>
        <definition>bool tubex::Tube::s_enable_syntheses</definition>
        <argsstring></argsstring>
        <name>s_enable_syntheses</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/simon/tubex-lib/src/core/dynamics/tube/tubex_Tube.h" line="1172" column="1" bodyfile="/home/simon/tubex-lib/src/core/dynamics/tube/tubex_Tube.h" bodystart="1172" bodyend="-1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="public-static-func">
      <memberdef kind="function" id="classtubex_1_1_tube_1a801d1a2117910d6ede9858a3509f4dd3" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>static bool tubex::Tube::same_slicing</definition>
        <argsstring>(const Tube &amp;x1, const Tube &amp;x2)</argsstring>
        <name>same_slicing</name>
        <param>
          <type>const <ref refid="classtubex_1_1_tube" kindref="compound">Tube</ref> &amp;</type>
          <declname>x1</declname>
        </param>
        <param>
          <type>const <ref refid="classtubex_1_1_tube" kindref="compound">Tube</ref> &amp;</type>
          <declname>x2</declname>
        </param>
        <briefdescription>
<para>Tests whether the two <ref refid="classtubex_1_1_tube" kindref="compound">Tube</ref> objects are sharing the same slicing. </para>        </briefdescription>
        <detaileddescription>
<para><simplesect kind="note"><para>If true, it means the two tubes are defined with the same amount of slices and identical sampling</para></simplesect>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>x1</parametername>
</parameternamelist>
<parameterdescription>
<para>the first <ref refid="classtubex_1_1_tube" kindref="compound">Tube</ref> </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>x2</parametername>
</parameternamelist>
<parameterdescription>
<para>the second <ref refid="classtubex_1_1_tube" kindref="compound">Tube</ref> </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>true in case of same slicing </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/simon/tubex-lib/src/core/dynamics/tube/tubex_Tube.h" line="1100" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classtubex_1_1_tube_1a40c761b40273a4b6333af4e999b0caf0" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>static void tubex::Tube::enable_syntheses</definition>
        <argsstring>(bool enable=true)</argsstring>
        <name>enable_syntheses</name>
        <param>
          <type>bool</type>
          <declname>enable</declname>
          <defval>true</defval>
        </param>
        <briefdescription>
<para>Enables the computation of a synthesis tree for any <ref refid="classtubex_1_1_tube" kindref="compound">Tube</ref> object. </para>        </briefdescription>
        <detaileddescription>
<para><simplesect kind="note"><para>A synthesis tree speeds up computations such as integrals or evaluations</para></simplesect>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>enable</parametername>
</parameternamelist>
<parameterdescription>
<para>boolean </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/simon/tubex-lib/src/core/dynamics/tube/tubex_Tube.h" line="1109" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classtubex_1_1_tube_1a83bb64701918511b0ee77d5873e13672" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>const <ref refid="classtubex_1_1_tube" kindref="compound">Tube</ref></type>
        <definition>static const Tube tubex::Tube::hull</definition>
        <argsstring>(const std::list&lt; Tube &gt; &amp;l_tubes)</argsstring>
        <name>hull</name>
        <param>
          <type>const std::list&lt; <ref refid="classtubex_1_1_tube" kindref="compound">Tube</ref> &gt; &amp;</type>
          <declname>l_tubes</declname>
        </param>
        <briefdescription>
<para>Computes the hull of several tubes. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>l_tubes</parametername>
</parameternamelist>
<parameterdescription>
<para>list of tubes </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>the tube enveloping the other ones </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/simon/tubex-lib/src/core/dynamics/tube/tubex_Tube.h" line="1117" column="1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="protected-func">
      <memberdef kind="function" id="classtubex_1_1_tube_1aad9fed9856cffe3a53106554d5a792af" prot="protected" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type></type>
        <definition>tubex::Tube::Tube</definition>
        <argsstring>()</argsstring>
        <name>Tube</name>
        <briefdescription>
<para>Creates a not-defined scalar tube. </para>        </briefdescription>
        <detaileddescription>
<para><simplesect kind="note"><para>Constructor necessary for the <ref refid="classtubex_1_1_tube_vector" kindref="compound">TubeVector</ref> class </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/simon/tubex-lib/src/core/dynamics/tube/tubex_Tube.h" line="1126" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classtubex_1_1_tube_1ab4a4982b8a936d6141bd47be4d192e28" prot="protected" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type>const ibex::IntervalVector</type>
        <definition>const ibex::IntervalVector tubex::Tube::codomain_box</definition>
        <argsstring>() const</argsstring>
        <name>codomain_box</name>
        <reimplements refid="classtubex_1_1_dynamical_item_1ab0a0aa7898dd77e1b59ecdcc32aee47d">codomain_box</reimplements>
        <briefdescription>
<para>Returns the box <formula id="262">$[x]([t_0,t_f])$</formula>. </para>        </briefdescription>
        <detaileddescription>
<para><simplesect kind="note"><para>Used for genericity purposes</para></simplesect>
<simplesect kind="return"><para>the envelope of codomain values </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/simon/tubex-lib/src/core/dynamics/tube/tubex_Tube.h" line="1135" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classtubex_1_1_tube_1a34175e26a8888d87f59336c28dfa7230" prot="protected" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void tubex::Tube::deserialize</definition>
        <argsstring>(const std::string &amp;binary_file_name, Trajectory *&amp;traj)</argsstring>
        <name>deserialize</name>
        <param>
          <type>const std::string &amp;</type>
          <declname>binary_file_name</declname>
        </param>
        <param>
          <type><ref refid="classtubex_1_1_trajectory" kindref="compound">Trajectory</ref> *&amp;</type>
          <declname>traj</declname>
        </param>
        <briefdescription>
<para>Restores a scalar tube from serialization, together with a <ref refid="classtubex_1_1_trajectory" kindref="compound">Trajectory</ref> object. </para>        </briefdescription>
        <detaileddescription>
<para><simplesect kind="note"><para>The <ref refid="classtubex_1_1_tube" kindref="compound">Tube</ref> and the <ref refid="classtubex_1_1_trajectory" kindref="compound">Trajectory</ref> must have been serialized beforehand by the appropriate method <ref refid="classtubex_1_1_tube_1ab6cb813c5fe3e3e6e1bd0bb0861552bb" kindref="member">serialize()</ref></para></simplesect>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>binary_file_name</parametername>
</parameternamelist>
<parameterdescription>
<para>path to the binary file </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>traj</parametername>
</parameternamelist>
<parameterdescription>
<para>a pointer to the <ref refid="classtubex_1_1_trajectory" kindref="compound">Trajectory</ref> object to be instantiated </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/simon/tubex-lib/src/core/dynamics/tube/tubex_Tube.h" line="1146" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classtubex_1_1_tube_1af8a9385ed2757dda7462531c6d42e275" prot="protected" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void tubex::Tube::create_synthesis_tree</definition>
        <argsstring>() const</argsstring>
        <name>create_synthesis_tree</name>
        <briefdescription>
<para>Creates the synthesis tree associated to the values of this tube. </para>        </briefdescription>
        <detaileddescription>
<para><simplesect kind="note"><para>The synthesis tree speeds up computations such as integrals or evaluations </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/simon/tubex-lib/src/core/dynamics/tube/tubex_Tube.h" line="1153" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classtubex_1_1_tube_1abc9a684e106e6327f8eb8de6e2f93fbe" prot="protected" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void tubex::Tube::delete_synthesis_tree</definition>
        <argsstring>() const</argsstring>
        <name>delete_synthesis_tree</name>
        <briefdescription>
<para>Deletes the synthesis tree of this tube. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/simon/tubex-lib/src/core/dynamics/tube/tubex_Tube.h" line="1158" column="1"/>
      </memberdef>
      </sectiondef>
    <briefdescription>
<para>One dimensional tube <formula id="77">$[x](\cdot)$</formula>, defined as an interval of scalar trajectories. </para>    </briefdescription>
    <detaileddescription>
<para><anchor id="classtubex_1_1_tube_1TUBE_CLASS"/> <simplesect kind="note"><para>Use <ref refid="classtubex_1_1_tube_vector" kindref="compound">TubeVector</ref> for the multi-dimensional case </para></simplesect>
</para>    </detaileddescription>
    <inheritancegraph>
      <node id="172">
        <label>tubex::Tube</label>
        <link refid="classtubex_1_1_tube"/>
        <childnode refid="173" relation="public-inheritance">
        </childnode>
      </node>
      <node id="173">
        <label>tubex::DynamicalItem</label>
        <link refid="classtubex_1_1_dynamical_item"/>
      </node>
    </inheritancegraph>
    <collaborationgraph>
      <node id="174">
        <label>tubex::Tube</label>
        <link refid="classtubex_1_1_tube"/>
        <childnode refid="175" relation="public-inheritance">
        </childnode>
        <childnode refid="176" relation="usage">
          <edgelabel>m_first_slice</edgelabel>
        </childnode>
      </node>
      <node id="175">
        <label>tubex::DynamicalItem</label>
        <link refid="classtubex_1_1_dynamical_item"/>
      </node>
      <node id="176">
        <label>tubex::Slice</label>
        <link refid="classtubex_1_1_slice"/>
        <childnode refid="175" relation="public-inheritance">
        </childnode>
        <childnode refid="176" relation="usage">
          <edgelabel>m_next_slice</edgelabel>
          <edgelabel>m_prev_slice</edgelabel>
        </childnode>
      </node>
    </collaborationgraph>
    <location file="/home/simon/tubex-lib/src/core/dynamics/tube/tubex_Tube.h" line="46" column="1" bodyfile="/home/simon/tubex-lib/src/core/dynamics/tube/tubex_Tube.h" bodystart="45" bodyend="1173"/>
    <listofallmembers>
      <member refid="classtubex_1_1_tube_1a8d16505bd2fd1bff9c545327f427cdc9" prot="public" virt="non-virtual"><scope>tubex::Tube</scope><name>bisect</name></member>
      <member refid="classtubex_1_1_tube_1a0ad5db5eb8ac2d8d64149a7f422349f6" prot="public" virt="virtual"><scope>tubex::Tube</scope><name>class_name</name></member>
      <member refid="classtubex_1_1_tube_1ab4e7b71c6fdd0a80603abfca5df37afd" prot="public" virt="non-virtual"><scope>tubex::Tube</scope><name>codomain</name></member>
      <member refid="classtubex_1_1_tube_1ab4a4982b8a936d6141bd47be4d192e28" prot="protected" virt="virtual"><scope>tubex::Tube</scope><name>codomain_box</name></member>
      <member refid="classtubex_1_1_tube_1a06cccd35da11ee89840ccd9c1f859ce8" prot="public" virt="non-virtual"><scope>tubex::Tube</scope><name>contains</name></member>
      <member refid="classtubex_1_1_tube_1af8a9385ed2757dda7462531c6d42e275" prot="protected" virt="non-virtual"><scope>tubex::Tube</scope><name>create_synthesis_tree</name></member>
      <member refid="classtubex_1_1_tube_1abc9a684e106e6327f8eb8de6e2f93fbe" prot="protected" virt="non-virtual"><scope>tubex::Tube</scope><name>delete_synthesis_tree</name></member>
      <member refid="classtubex_1_1_tube_1a34175e26a8888d87f59336c28dfa7230" prot="protected" virt="non-virtual"><scope>tubex::Tube</scope><name>deserialize</name></member>
      <member refid="classtubex_1_1_tube_1aa65bdf2e686e848d31ab4fd0cca0f35a" prot="protected" virt="non-virtual"><scope>tubex::Tube</scope><name>deserialize_Tube</name></member>
      <member refid="classtubex_1_1_tube_1afe5e200d7126a96527f49e98577a0116" prot="protected" virt="non-virtual"><scope>tubex::Tube</scope><name>deserialize_TubeVector</name></member>
      <member refid="classtubex_1_1_tube_1ac4bc81546b23aec26497e79c5db4a689" prot="public" virt="non-virtual"><scope>tubex::Tube</scope><name>diam</name></member>
      <member refid="classtubex_1_1_tube_1ac714458ae0ef21b29115cf955e5b44c6" prot="public" virt="non-virtual"><scope>tubex::Tube</scope><name>diam</name></member>
      <member refid="classtubex_1_1_tube_1a40c761b40273a4b6333af4e999b0caf0" prot="public" virt="non-virtual"><scope>tubex::Tube</scope><name>enable_syntheses</name></member>
      <member refid="classtubex_1_1_tube_1a3b627f4fc18a4236e294e8897cd1629f" prot="public" virt="non-virtual"><scope>tubex::Tube</scope><name>enable_synthesis</name></member>
      <member refid="classtubex_1_1_tube_1aba59999b9058969b74456eeb2d247253" prot="public" virt="non-virtual"><scope>tubex::Tube</scope><name>eval</name></member>
      <member refid="classtubex_1_1_tube_1aefff51e3f14ff342abdf5add61983732" prot="public" virt="non-virtual"><scope>tubex::Tube</scope><name>first_slice</name></member>
      <member refid="classtubex_1_1_tube_1ad220ef2076f25e3cc623b93c0e21e280" prot="public" virt="non-virtual"><scope>tubex::Tube</scope><name>first_slice</name></member>
      <member refid="classtubex_1_1_tube_1a61dbcbd96c4122d34f4dfa703956a258" prot="public" virt="non-virtual"><scope>tubex::Tube</scope><name>gate_exists</name></member>
      <member refid="classtubex_1_1_tube_1a83bb64701918511b0ee77d5873e13672" prot="public" virt="non-virtual"><scope>tubex::Tube</scope><name>hull</name></member>
      <member refid="classtubex_1_1_tube_1a1fe517f4eff444d72b2d6a5d682a8086" prot="public" virt="non-virtual"><scope>tubex::Tube</scope><name>index</name></member>
      <member refid="classtubex_1_1_tube_1a460ed0d2236efadf89433cc8e8ba65ca" prot="public" virt="non-virtual"><scope>tubex::Tube</scope><name>inflate</name></member>
      <member refid="classtubex_1_1_tube_1a6bda3d3184cdcd3d485280230119baa4" prot="public" virt="non-virtual"><scope>tubex::Tube</scope><name>inflate</name></member>
      <member refid="classtubex_1_1_tube_1ab05beac4591a5d692466ab7fb38a2250" prot="public" virt="non-virtual"><scope>tubex::Tube</scope><name>input2index</name></member>
      <member refid="classtubex_1_1_tube_1add1f58e49b074534b2688c72da564e62" prot="public" virt="non-virtual"><scope>tubex::Tube</scope><name>integral</name></member>
      <member refid="classtubex_1_1_tube_1ae9094d5b6b3960982fc14451669d537a" prot="public" virt="non-virtual"><scope>tubex::Tube</scope><name>integral</name></member>
      <member refid="classtubex_1_1_tube_1aae0985461a567f613977135c92e99533" prot="public" virt="non-virtual"><scope>tubex::Tube</scope><name>integral</name></member>
      <member refid="classtubex_1_1_tube_1a0ad03bafee1a07b25e57bcb71e2717b0" prot="public" virt="non-virtual"><scope>tubex::Tube</scope><name>interpol</name></member>
      <member refid="classtubex_1_1_tube_1a9f8f9e7d1a23dc299cd1b09c5d65e89b" prot="public" virt="non-virtual"><scope>tubex::Tube</scope><name>interpol</name></member>
      <member refid="classtubex_1_1_tube_1a1ec2b9cb1f6270fc6a6dff0b5e888d1e" prot="public" virt="non-virtual"><scope>tubex::Tube</scope><name>invert</name></member>
      <member refid="classtubex_1_1_tube_1a4cc01a70753a0cd19672f947275bfdda" prot="public" virt="non-virtual"><scope>tubex::Tube</scope><name>invert</name></member>
      <member refid="classtubex_1_1_tube_1a5f3132df3ec3d23435913f3ae8549c6e" prot="public" virt="non-virtual"><scope>tubex::Tube</scope><name>invert</name></member>
      <member refid="classtubex_1_1_tube_1a7d0b112a5833043bc3a80627e43ad90c" prot="public" virt="non-virtual"><scope>tubex::Tube</scope><name>invert</name></member>
      <member refid="classtubex_1_1_tube_1a2f1a51db56336eb0ef65d4ab1270f88a" prot="public" virt="non-virtual"><scope>tubex::Tube</scope><name>is_empty</name></member>
      <member refid="classtubex_1_1_tube_1a7c4e138008e222c131d53a55dee6adb1" prot="public" virt="non-virtual"><scope>tubex::Tube</scope><name>is_interior_subset</name></member>
      <member refid="classtubex_1_1_tube_1ae703e7dcf068ea3108c61f41629c6fbf" prot="public" virt="non-virtual"><scope>tubex::Tube</scope><name>is_strict_interior_subset</name></member>
      <member refid="classtubex_1_1_tube_1a7357b1f57a997286cf15a87cd60d03f9" prot="public" virt="non-virtual"><scope>tubex::Tube</scope><name>is_strict_subset</name></member>
      <member refid="classtubex_1_1_tube_1a4d192b51c15f101ef970106ce64494f5" prot="public" virt="non-virtual"><scope>tubex::Tube</scope><name>is_strict_superset</name></member>
      <member refid="classtubex_1_1_tube_1a37002cbe9e60394c42f8c87f401a6d51" prot="public" virt="non-virtual"><scope>tubex::Tube</scope><name>is_subset</name></member>
      <member refid="classtubex_1_1_tube_1a79914d4ffd1fc2ef7897bf165e5101f0" prot="public" virt="non-virtual"><scope>tubex::Tube</scope><name>is_superset</name></member>
      <member refid="classtubex_1_1_tube_1a4e6c7476fb3039cc23c63a9cd0e7da9a" prot="public" virt="non-virtual"><scope>tubex::Tube</scope><name>largest_slice</name></member>
      <member refid="classtubex_1_1_tube_1a70a61d72421a43b92f6f31cdbf36af7f" prot="public" virt="non-virtual"><scope>tubex::Tube</scope><name>largest_slice</name></member>
      <member refid="classtubex_1_1_tube_1aed886d0fb0cdf6510420d45bdd8dede6" prot="public" virt="non-virtual"><scope>tubex::Tube</scope><name>last_slice</name></member>
      <member refid="classtubex_1_1_tube_1a2f68de044f4a9e52b13146b1fbe92d45" prot="public" virt="non-virtual"><scope>tubex::Tube</scope><name>last_slice</name></member>
      <member refid="classtubex_1_1_tube_1a2cba1623d4aa00fc79db5eb8224797a9" prot="protected" virt="non-virtual"><scope>tubex::Tube</scope><name>m_enable_synthesis</name></member>
      <member refid="classtubex_1_1_tube_1a8c3037a4e9d23249429a98015507ff3b" prot="protected" virt="non-virtual"><scope>tubex::Tube</scope><name>m_first_slice</name></member>
      <member refid="classtubex_1_1_tube_1abf341f24f980f38357ccfcc8540d0e2c" prot="protected" virt="non-virtual"><scope>tubex::Tube</scope><name>m_synthesis_tree</name></member>
      <member refid="classtubex_1_1_tube_1a0d01c095852464d661996d5fd150b685" prot="protected" virt="non-virtual"><scope>tubex::Tube</scope><name>m_tdomain</name></member>
      <member refid="classtubex_1_1_tube_1af3b1558e4e4246ffb22f5d2ad2fe773c" prot="public" virt="non-virtual"><scope>tubex::Tube</scope><name>max_diam</name></member>
      <member refid="classtubex_1_1_tube_1a67c3fb105bc8e208b927bfdc35343d4b" prot="public" virt="non-virtual"><scope>tubex::Tube</scope><name>max_gate_diam</name></member>
      <member refid="classtubex_1_1_tube_1a67170647c4b88a6f9db567c1af3424bb" prot="public" virt="non-virtual"><scope>tubex::Tube</scope><name>nb_slices</name></member>
      <member refid="classtubex_1_1_tube_1abd9f0a2f67b6078c34ba7d8d2123c169" prot="public" virt="non-virtual"><scope>tubex::Tube</scope><name>operator &amp;=</name></member>
      <member refid="classtubex_1_1_tube_1ab277c93719ee67e9b74c64df37a729b1" prot="public" virt="non-virtual"><scope>tubex::Tube</scope><name>operator &amp;=</name></member>
      <member refid="classtubex_1_1_tube_1a90cbfe5ccf7eff3dc5b1ba8d59c8fbaf" prot="public" virt="non-virtual"><scope>tubex::Tube</scope><name>operator &amp;=</name></member>
      <member refid="classtubex_1_1_tube_1a8f962dab50c033072d8a5f08e9f3b4e5" prot="public" virt="non-virtual"><scope>tubex::Tube</scope><name>operator!=</name></member>
      <member refid="classtubex_1_1_tube_1acca046c9cdc721482d81369af865fcf7" prot="public" virt="non-virtual"><scope>tubex::Tube</scope><name>operator()</name></member>
      <member refid="classtubex_1_1_tube_1abd3fdbd49b6c37ce126a39859093345f" prot="public" virt="non-virtual"><scope>tubex::Tube</scope><name>operator()</name></member>
      <member refid="classtubex_1_1_tube_1af144d12fb5730bbf2ce81b762aaa1e49" prot="public" virt="non-virtual"><scope>tubex::Tube</scope><name>operator()</name></member>
      <member refid="classtubex_1_1_tube_1a1a781338288203674805cd6cf3aa4ef6" prot="public" virt="non-virtual"><scope>tubex::Tube</scope><name>operator*=</name></member>
      <member refid="classtubex_1_1_tube_1a7b17b6357a2b80b309194fee2d45fbb8" prot="public" virt="non-virtual"><scope>tubex::Tube</scope><name>operator*=</name></member>
      <member refid="classtubex_1_1_tube_1a65d93d892059de118773224e47e89ccd" prot="public" virt="non-virtual"><scope>tubex::Tube</scope><name>operator*=</name></member>
      <member refid="classtubex_1_1_tube_1a1c2f5a318a7b4b59935f907545bed48b" prot="public" virt="non-virtual"><scope>tubex::Tube</scope><name>operator+=</name></member>
      <member refid="classtubex_1_1_tube_1a9e4f61f0f587e9cea87a0eb9e531d804" prot="public" virt="non-virtual"><scope>tubex::Tube</scope><name>operator+=</name></member>
      <member refid="classtubex_1_1_tube_1aae7b9eed169971bb74094d24f55a212d" prot="public" virt="non-virtual"><scope>tubex::Tube</scope><name>operator+=</name></member>
      <member refid="classtubex_1_1_tube_1a42a0133b9ad4c07e9b40e72f807cc850" prot="public" virt="non-virtual"><scope>tubex::Tube</scope><name>operator-=</name></member>
      <member refid="classtubex_1_1_tube_1a624d0efd45b7ca92bdb383dc1d546109" prot="public" virt="non-virtual"><scope>tubex::Tube</scope><name>operator-=</name></member>
      <member refid="classtubex_1_1_tube_1ad1dd8d133ab63dc0a5eb8795857a7899" prot="public" virt="non-virtual"><scope>tubex::Tube</scope><name>operator-=</name></member>
      <member refid="classtubex_1_1_tube_1a68b0cd25a4de8b868b355552f7e28fa9" prot="public" virt="non-virtual"><scope>tubex::Tube</scope><name>operator/=</name></member>
      <member refid="classtubex_1_1_tube_1af3ed062e8f1184d7f7a0be587315d8f0" prot="public" virt="non-virtual"><scope>tubex::Tube</scope><name>operator/=</name></member>
      <member refid="classtubex_1_1_tube_1ae84fd06eeaf3573500662bb3ada1024c" prot="public" virt="non-virtual"><scope>tubex::Tube</scope><name>operator/=</name></member>
      <member refid="classtubex_1_1_tube_1ae9b1a489fad33a7319c3ce6d6721b707" prot="public" virt="non-virtual"><scope>tubex::Tube</scope><name>operator&lt;&lt;</name></member>
      <member refid="classtubex_1_1_tube_1a506093e88fd27ccebca375a54ade22af" prot="public" virt="non-virtual"><scope>tubex::Tube</scope><name>operator=</name></member>
      <member refid="classtubex_1_1_tube_1a826f648430569f48413bd5098aa04bbe" prot="public" virt="non-virtual"><scope>tubex::Tube</scope><name>operator==</name></member>
      <member refid="classtubex_1_1_tube_1ab4f96e40e1ccf1616e570730bd2f12c0" prot="public" virt="non-virtual"><scope>tubex::Tube</scope><name>operator|=</name></member>
      <member refid="classtubex_1_1_tube_1ad80666b632c2d81e3c5455c34c503d10" prot="public" virt="non-virtual"><scope>tubex::Tube</scope><name>operator|=</name></member>
      <member refid="classtubex_1_1_tube_1a4b38a2352e9a5dd1ed8662612a9795e6" prot="public" virt="non-virtual"><scope>tubex::Tube</scope><name>operator|=</name></member>
      <member refid="classtubex_1_1_tube_1a65eb032f4186044e3dd46336ace13629" prot="public" virt="non-virtual"><scope>tubex::Tube</scope><name>overlaps</name></member>
      <member refid="classtubex_1_1_tube_1a5f47c14bf9837186f2eb0003b56d1c96" prot="public" virt="non-virtual"><scope>tubex::Tube</scope><name>partial_integral</name></member>
      <member refid="classtubex_1_1_tube_1a4ea8ee3b43cdba6ab2c178c54901d00b" prot="public" virt="non-virtual"><scope>tubex::Tube</scope><name>partial_integral</name></member>
      <member refid="classtubex_1_1_tube_1a152083473005e3d8fe6d0e75b658ee08" prot="public" virt="non-virtual"><scope>tubex::Tube</scope><name>polygon_envelope</name></member>
      <member refid="classtubex_1_1_tube_1aaecfc3d1ebc5d4ca0a88d65ea2349015" prot="public" virt="non-virtual"><scope>tubex::Tube</scope><name>primitive</name></member>
      <member refid="classtubex_1_1_tube_1a39a4b25586279ea119126ecda1c64794" prot="public" virt="non-virtual"><scope>tubex::Tube</scope><name>remove_gate</name></member>
      <member refid="classtubex_1_1_tube_1a15f696984ecc1442b6aec9ced82b1da8" prot="protected" virt="non-virtual"><scope>tubex::Tube</scope><name>s_enable_syntheses</name></member>
      <member refid="classtubex_1_1_tube_1a801d1a2117910d6ede9858a3509f4dd3" prot="public" virt="non-virtual"><scope>tubex::Tube</scope><name>same_slicing</name></member>
      <member refid="classtubex_1_1_tube_1a98f8819bd664504a4dd1e9f85e352478" prot="public" virt="non-virtual"><scope>tubex::Tube</scope><name>sample</name></member>
      <member refid="classtubex_1_1_tube_1abe1856d09554df0722c2baff34b45170" prot="public" virt="non-virtual"><scope>tubex::Tube</scope><name>sample</name></member>
      <member refid="classtubex_1_1_tube_1a4c6b506b8761f731ebb2cb4277070a66" prot="public" virt="non-virtual"><scope>tubex::Tube</scope><name>sample</name></member>
      <member refid="classtubex_1_1_tube_1ab19a4eade55e650dcd20867912528742" prot="public" virt="non-virtual"><scope>tubex::Tube</scope><name>sample</name></member>
      <member refid="classtubex_1_1_tube_1ab6cb813c5fe3e3e6e1bd0bb0861552bb" prot="public" virt="non-virtual"><scope>tubex::Tube</scope><name>serialize</name></member>
      <member refid="classtubex_1_1_tube_1a00ab3eefcfc6c60cd909d5c85fd34049" prot="public" virt="non-virtual"><scope>tubex::Tube</scope><name>serialize</name></member>
      <member refid="classtubex_1_1_tube_1aa90ac102791a0c2a9934ccae3f4185a1" prot="public" virt="non-virtual"><scope>tubex::Tube</scope><name>set</name></member>
      <member refid="classtubex_1_1_tube_1a1e0d0a5a1722bc1e68ef152e7de77113" prot="public" virt="non-virtual"><scope>tubex::Tube</scope><name>set</name></member>
      <member refid="classtubex_1_1_tube_1ac3c1f8930f62f0da9d396fcf9ee09e29" prot="public" virt="non-virtual"><scope>tubex::Tube</scope><name>set</name></member>
      <member refid="classtubex_1_1_tube_1afd55b2b3d8ea432b4335e9e8bcf45d4c" prot="public" virt="non-virtual"><scope>tubex::Tube</scope><name>set</name></member>
      <member refid="classtubex_1_1_tube_1a8f8b3b2ac5ee4f5db9e53f0707290abf" prot="public" virt="non-virtual"><scope>tubex::Tube</scope><name>set_empty</name></member>
      <member refid="classtubex_1_1_tube_1a48704a8fff2c68cbc5586d3e26a3b15d" prot="public" virt="non-virtual"><scope>tubex::Tube</scope><name>shift_tdomain</name></member>
      <member refid="classtubex_1_1_tube_1ac33744367c5632c9b6b6b919fc1c03f9" prot="public" virt="virtual"><scope>tubex::Tube</scope><name>size</name></member>
      <member refid="classtubex_1_1_tube_1a516e9785b96b1e1c7157cead95dbe025" prot="public" virt="non-virtual"><scope>tubex::Tube</scope><name>slice</name></member>
      <member refid="classtubex_1_1_tube_1a5b9a37448fd24c00d20979b8b508eee4" prot="public" virt="non-virtual"><scope>tubex::Tube</scope><name>slice</name></member>
      <member refid="classtubex_1_1_tube_1a7af6ac2e557256be168186a6731fb431" prot="public" virt="non-virtual"><scope>tubex::Tube</scope><name>slice</name></member>
      <member refid="classtubex_1_1_tube_1a9192742ad6c98ed41ab53542c6f3a7cb" prot="public" virt="non-virtual"><scope>tubex::Tube</scope><name>slice</name></member>
      <member refid="classtubex_1_1_tube_1acf511e5e9f2bb71588112a9ed05a5f6c" prot="public" virt="non-virtual"><scope>tubex::Tube</scope><name>slice_tdomain</name></member>
      <member refid="classtubex_1_1_tube_1a6bc9d8e66761fd3a69e2907a9cd85efc" prot="public" virt="virtual"><scope>tubex::Tube</scope><name>tdomain</name></member>
      <member refid="classtubex_1_1_tube_1ac91f4b104f474a0940f897a75aae82d8" prot="public" virt="non-virtual"><scope>tubex::Tube</scope><name>Tube</name></member>
      <member refid="classtubex_1_1_tube_1af4e716a0e7fb4329871bc234d4294cfa" prot="public" virt="non-virtual"><scope>tubex::Tube</scope><name>Tube</name></member>
      <member refid="classtubex_1_1_tube_1ac07929ace82b7303888f8378a48f2147" prot="public" virt="non-virtual"><scope>tubex::Tube</scope><name>Tube</name></member>
      <member refid="classtubex_1_1_tube_1a1714cc72ebc4d52f40d60b72ef7d6ad6" prot="public" virt="non-virtual"><scope>tubex::Tube</scope><name>Tube</name></member>
      <member refid="classtubex_1_1_tube_1a665f923072ea0ee7fe4efcd6f538d529" prot="public" virt="non-virtual"><scope>tubex::Tube</scope><name>Tube</name></member>
      <member refid="classtubex_1_1_tube_1a0b62385ad38bc9769e88cd5d81047154" prot="public" virt="non-virtual"><scope>tubex::Tube</scope><name>Tube</name></member>
      <member refid="classtubex_1_1_tube_1a4e227ab701eb3ff9264e2c4459a1414b" prot="public" virt="non-virtual"><scope>tubex::Tube</scope><name>Tube</name></member>
      <member refid="classtubex_1_1_tube_1ab23c1783a0736340c03b1c737cc82690" prot="public" virt="non-virtual"><scope>tubex::Tube</scope><name>Tube</name></member>
      <member refid="classtubex_1_1_tube_1a5d1633d16c844c2c38f8c9975d9023b0" prot="public" virt="non-virtual"><scope>tubex::Tube</scope><name>Tube</name></member>
      <member refid="classtubex_1_1_tube_1a8f1128f8c38b6ae3dc0122a6f6046935" prot="public" virt="non-virtual"><scope>tubex::Tube</scope><name>Tube</name></member>
      <member refid="classtubex_1_1_tube_1a0580667fecbabea51daa2fb8f755e3cf" prot="public" virt="non-virtual"><scope>tubex::Tube</scope><name>Tube</name></member>
      <member refid="classtubex_1_1_tube_1aad9fed9856cffe3a53106554d5a792af" prot="protected" virt="non-virtual"><scope>tubex::Tube</scope><name>Tube</name></member>
      <member refid="classtubex_1_1_dynamical_item_1a7f6b4b06ce678dc450ede373160c1144" prot="public" virt="non-virtual"><scope>tubex::Tube</scope><name>valid_tdomain</name></member>
      <member refid="classtubex_1_1_tube_1ace62e25555cd3367bf2aa08373560784" prot="public" virt="non-virtual"><scope>tubex::Tube</scope><name>volume</name></member>
      <member refid="classtubex_1_1_tube_1a1c7ec454c5338ff613beee4ee7f85f81" prot="public" virt="non-virtual"><scope>tubex::Tube</scope><name>wider_slice</name></member>
      <member refid="classtubex_1_1_tube_1aeb614c52143b053e374bb9a6a3821225" prot="public" virt="non-virtual"><scope>tubex::Tube</scope><name>wider_slice</name></member>
      <member refid="classtubex_1_1_dynamical_item_1a8a19adbf4f8b8c486efd6788c63a986b" prot="public" virt="virtual"><scope>tubex::Tube</scope><name>~DynamicalItem</name></member>
      <member refid="classtubex_1_1_tube_1a46cf4d1c4944715c5d220712be040b67" prot="public" virt="non-virtual"><scope>tubex::Tube</scope><name>~Tube</name></member>
    </listofallmembers>
  </compounddef>
</doxygen>
